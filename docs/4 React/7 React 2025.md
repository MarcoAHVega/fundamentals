---
sidebar_position: 7
---

# React 2025

---

## Module 1: JavaScript to React

### **Purpose**

This module is designed to equip learners with the essential JavaScript knowledge required for React development. It emphasizes focusing on relevant aspects of JavaScript without needing to master the entire language.

### **Key Learning Areas**

1. **Functions as Reusable Components**

   - Understanding functions as modular and reusable "slices" of the user interface.
   - Leveraging functions to build dynamic and flexible applications.

2. **Control Flow with Conditionals**

   - Using conditionals to manage application behavior.
   - Dynamically controlling what the user sees and determining code execution paths.

3. **Sharing Code with Modules**

   - Organizing code by sharing functions and variables.
   - Leveraging JavaScript modules for cleaner, more maintainable code.

4. **Mastering Objects and Arrays**

   - Efficiently creating and manipulating object and array structures.
   - Utilizing advanced array methods for dynamic data handling.

5. **Asynchronous Programming**
   - Working with asynchronous operations using Promises.
   - Mastering the `async/await` syntax for handling real-time data and API interactions.

### **Why This Matters**

React is deeply intertwined with JavaScript; improving JavaScript proficiency inherently enhances React development skills.

### **Conclusion**

The module emphasizes practical JavaScript skills directly applicable to building robust React applications. By mastering these key areas, learners will develop a solid foundation for creating efficient and scalable React apps.

---

## Functions

>

### 1. **Functions as UI**

To dynamically update UI content, use JavaScript functions and template literals.

#### Problem

Display "Hello Python" using the `getLanguage` function.

#### Key Concepts

- Use template literals with backticks (`` ` ``) for dynamic content.
- Embed variables using `${}`.
- Ensure the function returns the intended string.

#### Solution Code

```javascript
function getLanguage() {
  return 'Python'
}

document.body.innerHTML = `<h1>Hello ${getLanguage()}</h1>`
```

#### Notes

- Without `return`, the function outputs `undefined`.
- Ensure the function is called, not referenced (`getLanguage()` vs `getLanguage`).

---

### 2. **Function Arguments**

Create dynamic UI elements by passing arguments to functions.

#### Problem

Make the button text dynamic.

#### Key Concepts

- Use arguments in functions to modify content dynamically.
- Inline styles and additional arguments can enhance reusability.

#### Solution Code

```javascript
function createButton(action) {
  return `<button>${action} video</button>`
}

document.body.innerHTML = `
    ${createButton('Like')}
    ${createButton('Dislike')}
`
```

#### Notes

- Use additional arguments for styles:
  ```javascript
  function createButton(action, style) {
    return `<button style="${style}">${action} video</button>`
  }
  ```

---

### 3. **Function Composition**

Combine multiple components to build a functional UI (e.g., video player).

#### Problem

Create a video player with a header, video, and buttons.

#### Key Concepts

- Compose functions for headers, videos, and buttons.
- Pass arguments for attributes like `src`, `style`, etc.

#### Solution Code

```javascript
function createHeader(title) {
  return `<h1>Watch ${title}</h1>`
}

function createVideo(src, height = '300px', width = '100%') {
  return `<video src="${src}" controls style="height:${height}; width:${width};"></video>`
}

function createButton(action, color) {
  return `<button style="background-color:${color};">${action} video</button>`
}

document.body.innerHTML = `
    ${createHeader('Big Buck Bunny')}
    ${createVideo('big_buck_bunny.mp4')}
    <div style="margin-top: 20px;">
        ${createButton('Like', 'green')}
        ${createButton('Dislike', 'red')}
    </div>
`
```

#### Notes

- Styles can be applied dynamically through arguments.
- Encapsulate UI logic in reusable functions.

---

### 4. **Passing Arguments**

Break markup into reusable components.

#### Problem

Split the page into components for the title and cover image.

#### Key Concepts

- Pass arguments for properties like `src`, `height`, `width`.
- Provide fallback values using default parameters.

#### Solution Code

```javascript
function createTitle(title) {
  return `<h1>${title}</h1>`
}

function createCoverImage(src, height = '300px', width = '520px') {
  return `<img src="${src}" style="height:${height}; width:${width};"/>`
}

document.body.innerHTML = `
    ${createTitle('My Computer Setup')}
    ${createCoverImage('cover.jpg')}
`
```

#### Notes

- Default parameters handle missing arguments.
- Fallback values prevent broken UI when arguments are missing.

---

### 5. **Passing Objects as Arguments**

Simplify argument management by using objects.

#### Problem

Pass all profile data as a single object.

#### Key Concepts

- Use objects to group related data.
- Access properties using `object.property`.

#### Solution Code

```javascript
const profileProps = {
  src: 'profile.jpg',
  name: 'John Doe',
}

function createProfile(props) {
  return `
        <div>
            <img src="${props.src}" alt="Profile Picture"/>
            <h2>${props.name || 'Anonymous'}</h2>
        </div>
    `
}

document.body.innerHTML = createProfile(profileProps)
```

#### Notes

- Provide fallback values using `||`.
- Consolidates data into a single, manageable structure.

### **Summary**

- **Template Literals:** For dynamic HTML content.
- **Function Arguments:** Increase flexibility.
- **Function Composition:** Build reusable, modular UI components.
- **Default Parameters:** Provide fallback values.
- **Object Arguments:** Simplify and structure data passing.

These practices align with modern JavaScript principles and ease the transition to frameworks like React.

---

## Conditionals

>

### 1. **If Statements**

>

#### Problem

Write a conditional that:

- Displays `"authenticated content"` if the user is authenticated (`isAuth` is `true`).
- Displays `"Log in here"` if `isAuth` is `false`.

#### Solution

```javascript
if (isAuth) {
  console.log('authenticated content')
} else {
  console.log('Log in here')
}
```

#### Explanation

- The `if` condition checks if `isAuth` is true.
- If true, it executes the block that shows authenticated content.
- Otherwise, it falls back to the `else` block and displays the unauthenticated message.

---

### 2. **Ternary Expressions**

>

#### Problem

Rewrite the above conditional using a ternary operator.

#### Solution

```javascript
console.log(isAuth ? 'authenticated content' : 'Log in here')
```

#### Explanation

- The ternary operator `?` is a concise alternative to `if-else`.
- Syntax: `condition ? expression_if_true : expression_if_false`.

---

### 3. **Nested Ternaries**

>

#### Problem

Display the user's avatar if it exists; otherwise, display a default avatar.

#### Solution

```javascript
const avatarSrc = user.avatar ? user.avatar : defaultAvatar
console.log(`<img src="${avatarSrc}" width="100px" alt="User Avatar">`)
```

**Shortened Version Using OR (`||`):**

```javascript
const avatarSrc = user.avatar || defaultAvatar
console.log(`<img src="${avatarSrc}" width="100px" alt="User Avatar">`)
```

#### Explanation

- `user.avatar` is checked for truthiness. If it exists, its value is used.
- The `||` operator provides a fallback when the first value is falsy.

---

### 4. **Hide Content**

>

#### Problem

1. Hide all markup if `user.avatar` is not present.
2. Hide only the avatar if `user.avatar` is not present.

#### Solution

**1. Hide All Markup**

```javascript
if (!user.avatar) {
  return '' // Return an empty string or null to hide all markup
}
```

**2. Hide Only the Avatar**

```javascript
const avatarMarkup = user.avatar ? `<img src="${user.avatar}" alt="User Avatar">` : ''
console.log(`<div>${avatarMarkup}</div>`)
```

#### Explanation

- Use an early return for hiding all content.
- Use a ternary operator to selectively hide/show specific elements.

---

### 5. **Conditional Styles**

>

#### Problem

Change the `DownloadButton`:

- If `isPaid` is `true`: Add the `.paid` class with the text `"Buy Now"`.
- If `isPaid` is `false`: Use a green background with the text `"Download Free"`.

#### Solution

```javascript
const buttonClass = `download-button ${props.isPaid ? 'paid' : ''}`.trim()
const buttonText = props.isPaid ? 'Buy Now' : 'Download Free'

console.log(`<button class="${buttonClass}">${buttonText}</button>`)
```

#### Explanation

- Use a template literal to dynamically add or omit the `paid` class.
- Use a ternary operator for conditional text.
- `.trim()` ensures no extra spaces if the class is empty.

### **Key Notes**

- **Ternaries**: Ideal for concise conditions but avoid deep nesting to maintain readability.
- **Early Returns**: Simplify conditionals by returning early for exceptional cases.
- **Conditional Classes**: Combine base classes with dynamic ones using template literals or class libraries (like `classnames` in React).

These examples cover practical applications for JavaScript conditionals, useful for React and other frameworks.

---

## Arrays

### 1. **Display Content with Map**

Using `map` to Transform and Display Arrays

#### Problem

Transform a list of features from HTML content into an array and display each as a list item dynamically.

#### Steps

1. Extract text from HTML list items.
2. Store the texts as elements in an array named `features`.
3. Use the `.map()` function to generate `<li>` elements.

#### Example Code

```javascript
const features = ['Feature 1', 'Feature 2', 'Feature 3']

const featureList = features.map(feature => `<li>${feature}</li>`).join('')
document.querySelector('ul#features').innerHTML = featureList
```

---

### 2. **Transform Arrays with Map**

Mapping Arrays of Objects to Components

#### Problem

Use an array of objects to display details (e.g., team members) as HTML components.

#### Steps

1. Create an array of objects containing member details (e.g., `name`, `role`, `imageUrl`).
2. Use `.map()` to iterate and generate HTML.
3. Avoid unnecessary properties (e.g., `twitterUrl`, `linkedinUrl`).

#### Example Code

```javascript
const members = [
  { name: 'Alice', role: 'Developer', imageUrl: 'alice.jpg' },
  { name: 'Bob', role: 'Designer', imageUrl: 'bob.jpg' },
]

const memberHTML = members
  .map(
    member => `
  <div class="member">
    <img src="${member.imageUrl}" alt="${member.name}">
    <h3>${member.name}</h3>
    <p>${member.role}</p>
  </div>
`
  )
  .join('')
document.querySelector('.members').innerHTML = memberHTML
```

---

### 3. **Filtering Arrays with `filter`**

>

#### Problem

Separate an array of links into "Support" and "Company" categories based on the path.

#### Steps

1. Use `.filter()` to extract relevant links for each category.
2. Use `.map()` to generate and display HTML for the filtered results.

#### Example Code

```javascript
const links = [
  { href: '/support/pricing', text: 'Pricing' },
  { href: '/support/documentation', text: 'Documentation' },
  { href: '/company/about', text: 'About Us' },
]

const supportLinks = links.filter(link => link.href.startsWith('/support'))
const companyLinks = links.filter(link => link.href.startsWith('/company'))

const supportHTML = supportLinks.map(link => `<a href="${link.href}">${link.text}</a>`).join('')
const companyHTML = companyLinks.map(link => `<a href="${link.href}">${link.text}</a>`).join('')

document.querySelector('#support-links').innerHTML = supportHTML
document.querySelector('#company-links').innerHTML = companyHTML
```

---

### 4.**Map with Inner Function**

Nested Lists with `map` and `filter`

#### Problem

Filter vegetarian recipes and display their names along with a nested list of ingredients.

#### Steps

1. Use `.filter()` to include only vegetarian recipes.
2. Use `.map()` to create HTML for the recipes and their ingredients.

#### Example Code

```javascript
const recipes = [
  { name: 'Salad', isVegetarian: true, ingredients: ['Lettuce', 'Tomato', 'Cucumber'] },
  { name: 'Burger', isVegetarian: false, ingredients: ['Bun', 'Beef', 'Cheese'] },
]

const vegetarianRecipes = recipes.filter(recipe => recipe.isVegetarian)

const recipeHTML = vegetarianRecipes
  .map(
    recipe => `
  <div class="recipe">
    <h3>${recipe.name}</h3>
    <ul>
      ${recipe.ingredients.map(ingredient => `<li>${ingredient}</li>`).join('')}
    </ul>
  </div>
`
  )
  .join('')

document.querySelector('#recipes').innerHTML = recipeHTML
```

---

### 5.**Nested Lists**

Displaying Conditional Content with Ternaries\*\*

#### Problem

Use a boolean property (e.g., `done`) to conditionally render content for each item in a todo list.

#### Steps

1. Use `.map()` to iterate over the todo list.
2. Include a ternary operator to render different content based on the `done` property.

#### Example Code

```javascript
const todos = [
  { text: 'Buy groceries', done: true },
  { text: 'Clean house', done: false },
]

const todoHTML = todos
  .map(
    todo => `
  <li>
    <span>${todo.done ? '✅' : '❌'}</span> 
    <span>${todo.text}</span>
  </li>
`
  )
  .join('')

document.querySelector('#todo-list').innerHTML = todoHTML
```

### **Key Notes on `map` and `filter`**

- **`map()`**: Transforms each element of an array into a new array.
- **`filter()`**: Returns a new array containing elements that satisfy a condition.
- Use **template literals** (``) for clean inline HTML generation.
- Use **`.join('')`** after `map` to remove commas when rendering strings.

These examples incorporate common practices in React and JavaScript, making them suitable for both beginner and advanced learners.

---

## Objects

>

### 1. **Destructuring**

>

#### **Problem**

Destructure `id`, `label`, and `defaultChecked` from an object passed to a `Checkbox` component and use these variables appropriately.

#### **Solution**

```jsx
function Checkbox({ id, label, defaultChecked }) {
  return (
    <div>
      <input
        type='checkbox'
        id={id}
        defaultChecked={defaultChecked}
      />
      <label htmlFor={id}>{label}</label>
    </div>
  )
}
```

**Explanation:**

- `id` is used for the `id` attribute.
- `label` is the label text displayed.
- `defaultChecked` determines the checkbox's initial state.

---

### 2. **Rest Operator**

>

#### **Problem**

Destructure the `src` property from the object passed to an `Avatar` component. Use the rest operator to gather other properties.

#### **Solution**

```jsx
function Avatar({ src, ...rest }) {
  return (
    <img
      src={src}
      alt={rest.alt}
      style={{ borderRadius: rest.borderRadius }}
    />
  )
}
```

**Explanation:**

- `src` is destructured for the `src` attribute.
- `...rest` gathers remaining properties like `alt` and `borderRadius`.

---

### 3. **Default Values**

>

#### **Problem**

Provide default fallback values for missing properties:

- `author`: "Someone"
- `text`: "No message"
- `time`: ""

#### **Solution**

```jsx
function Message({ author = 'Someone', text = 'No message', time = '' }) {
  return (
    <div>
      <strong>{author}</strong> commented {time}
      <p>{text}</p>
    </div>
  )
}
```

**Explanation:**

- Default values are specified in the destructuring assignment to handle missing data gracefully.

---

### 4. **Spread Operator**

>

#### **Problem**

Add properties from a `livesIn` object to each user and display their location.

#### **Solution**

```jsx
const users = [
  { name: 'John', email: 'john@example.com' },
  { name: 'Jane', email: 'jane@example.com' },
]

const livesIn = { state: 'California', country: 'USA' }

const updatedUsers = users.map(user => ({
  ...user,
  ...livesIn,
}))

updatedUsers.forEach(user => {
  console.log(`${user.name} lives in ${user.state}, ${user.country}`)
})
```

**Explanation:**

- The spread operator is used to merge `user` and `livesIn`.

---

### 5. **Nested Spread Operator**

>

#### **Problem**

Add a `today` property to the nested `record` property in a stats object.

#### **Solution**

```jsx
const stats = [
  { id: 1, record: { name: 'Subscribers', value: 1200 } },
  { id: 2, record: { name: 'Open Rate', value: 75 } },
]

const updatedStats = stats.map(stat => ({
  ...stat,
  record: {
    ...stat.record,
    date: 'today',
  },
}))

updatedStats.forEach(stat => {
  console.log(`${stat.record.name}: ${stat.record.value} as of ${stat.record.date}`)
})
```

**Explanation:**

- The first spread operator copies `stat`.
- The nested spread operator copies and updates `record`.

### **General Notes**

1. **Destructuring**: Extracts specific properties for cleaner and more readable code.
2. **Rest Operator**: Gathers remaining properties into an object, useful for flexible handling of additional attributes.
3. **Default Values**: Provides fallback values to ensure components handle missing props gracefully.
4. **Spread Operator**: Combines or extends objects and arrays efficiently, avoiding mutation.
5. **Nested Spread Operator**: Updates deeply nested structures while maintaining immutability.

---

## Promises

>

### 1. **Promise Chaining and Fetch API**

>

#### Problem: Display the Count of Star Wars Characters

Use the Fetch API to retrieve data and display the count value in the UI.

#### Code Example

```javascript
fetch('https://swapi.dev/api/people/')
  .then(response => response.json()) // Parse the JSON response
  .then(data => {
    const count = data.count
    document.getElementById('characters').textContent = count // Update UI
  })
  .catch(error => console.error('Error:', error))
```

#### Key Points

- **`fetch`** returns a promise.
- Use **`.then()`** to handle the response and parse JSON.
- Update the DOM with the retrieved data.

---

### 2. **Error Handling with Promises**

>

#### Problem: Handle Fetch Errors and Update UI

Check the `.ok` property of the response to detect request errors.

#### Code Example

```javascript
fetch('https://swapi.dev/api/people/')
  .then(response => {
    if (!response.ok) {
      throw new Error('Error making request')
    }
    return response.json()
  })
  .then(data => {
    document.getElementById('characters').textContent = data.count
  })
  .catch(error => {
    console.error(error)
    document.getElementById('error-message').textContent = 'Could not fetch data.'
  })
```

#### Key Points

- Check `.ok` to confirm the request succeeded.
- Use **`.catch()`** for error handling.

---

### 3. **Finally Callback**

>

#### Problem: Cleanup After Promise Resolution

Use `.finally()` to remove a loading indicator.

#### Code Example

```javascript
const loadingElement = document.getElementById('loading')

fetch('https://swapi.dev/api/people/')
  .then(response => response.json())
  .then(data => {
    document.getElementById('characters').textContent = data.count
  })
  .catch(error => {
    console.error('Error:', error)
  })
  .finally(() => {
    loadingElement.remove() // Remove loading indicator
  })
```

#### Key Points

- `.finally()` is called regardless of success or failure.
- Ideal for cleanup operations like hiding spinners.

---

### 4. **Async/Await Syntax**

>

#### Problem: Simplify Promise Handling

Replace `.then()` chains with `async/await`.

#### Code Example

```javascript
async function fetchCharacters() {
  try {
    const response = await fetch('https://swapi.dev/api/people/')
    if (!response.ok) {
      throw new Error('Error making request')
    }
    const data = await response.json()
    document.getElementById('characters').textContent = data.count
  } catch (error) {
    console.error(error)
    document.getElementById('error-message').textContent = 'Could not fetch data.'
  } finally {
    document.getElementById('loading').remove()
  }
}

fetchCharacters()
```

#### Key Points

- Use `await` for promises to maintain a synchronous-like flow.
- Wrap `await` calls in `try/catch` for error handling.
- `finally` is used for cleanup.

---

### 5. **Complete Async/Await Solution**

>

#### Problem: Display Star Wars Film Count

Use `async/await`, handle errors, and clean up the UI.

#### Code Example

```javascript
async function fetchFilms() {
  try {
    const response = await fetch('https://swapi.dev/api/films/')
    if (!response.ok) {
      throw new Error('Error fetching films')
    }
    const data = await response.json()
    document.getElementById('films').textContent = data.count
  } catch (error) {
    console.error(error)
    document.getElementById('error-message').textContent = 'Error fetching films.'
  } finally {
    document.getElementById('loading').remove()
  }
}

fetchFilms()
```

#### Challenge

- Modify the example to display a list of film titles in the UI.

These notes provide a solid foundation for understanding and working with promises and `async/await`.

---

## Module 2: React Essentials

>

#### Introduction

- **Focus**: Understanding the building blocks and dynamics of React after grasping JavaScript fundamentals.
- **Key Areas**:
  - Elements vs. Plain HTML.
  - JSX and its integration with JavaScript.

#### Building Blocks of React

1. **React Elements**:

   - Core components of React.
   - Similarities and differences with HTML elements.

2. **JSX (JavaScript XML)**:
   - Appears unusual but offers dynamic capabilities by combining HTML-like syntax with JavaScript.

#### React Components

- **Custom Elements**:

  - Built using React components.
  - Resemble JavaScript functions with specific quirks.

- **Key Features**:
  - Handle DOM rendering.
  - Require predictable data inputs (props).
  - Output only JSX without side effects.

#### Data Handling with Props

- **Props**:
  - Enable dynamic behavior in components.
  - Facilitate data flow into components.
  - Patterns include:
    - **Prop Destructuring**: Extracting values for simpler usage.
    - **Composition with `children` Prop**: Building nested or reusable components.

#### Managing State in React

- **State**:

  - Represents the "memory" of a React application.
  - Tracks data across a component's lifecycle.

- **Key Concepts**:

  - **useState Hook**: Initialize and update local state.
  - Handling multiple state variables.
  - Using arrays and objects as state variables.

- **Patterns**:
  - **Lifting State Up**: Share state between components.

---

## Elements

>

### 1. **HTML to JSX**

**Key Points**:

- JSX is syntactically similar to HTML but adheres to JavaScript rules.
- Use `className` instead of `class`.
- Close self-closing tags with `/>`.
- Wrap all JSX elements within a single parent element.

**Code Example**:

```jsx
export default function Pricing() {
  return (
    <div>
      <h2 className='title'>Simple no-tricks pricing</h2>
      <hr />
      <a
        href='/buy'
        className='button'>
        Buy Now <span aria-hidden='true'>→</span>
      </a>
    </div>
  )
}
```

---

### 2. **Dynamic Data with Curly Braces**

**Key Points**:

- Use curly braces `{}` to insert JavaScript expressions in JSX.
- Access properties dynamically from objects or variables.

**Code Example**:

```jsx
const bannerData = {
  version: 4,
  icon: <Icon />,
  href: '/new',
}

export default function Banner() {
  return (
    <div>
      <h2>What's new in version {bannerData.version}</h2>
      <a href={bannerData.href}>{bannerData.icon}</a>
    </div>
  )
}
```

---

### 3. **Inline Styles**

**Key Points**:

- Inline styles in JSX are objects, with camelCased property names.
- Use double curly braces `{{}}` to define styles.

**Code Example**:

```jsx
<button style={{ backgroundColor: 'green', color: 'white' }}>Create</button>
<button style={{ backgroundColor: 'darkorange', color: 'white' }}>Update</button>
<button style={{ backgroundColor: 'red', color: 'white', fontWeight: 'bold' }}>Delete</button>
```

---

### 4. **Conditionals in JSX**

**Key Points**:

- Use ternary operators or logical operators (`&&`) for conditional rendering.
- Return `null` to hide components.

**Code Example**:

```jsx
const isSaleOpen = true

export default function SaleBanner() {
  return (
    <div>
      <h2>{isSaleOpen ? 'Sale is On!' : 'Sale has Ended'}</h2>
      {isSaleOpen && <a href='/sale'>Shop Now</a>}
    </div>
  )
}
```

---

### 5. **Hiding Elements**

**Key Points**:

- Use early returns to hide components entirely.
- Conditional rendering based on variables or expressions.

**Code Example**:

```jsx
const review = { author: 'John', rating: 4, content: 'Great product!' }

export default function Review() {
  if (!review.author) return null

  const isGoodReview = review.rating >= 4

  return (
    <div>
      <h4>{review.author}</h4>
      <p>{isGoodReview ? review.content : 'No review'}</p>
      {isGoodReview && <div>⭐⭐⭐⭐</div>}
    </div>
  )
}
```

---

### 6. **Conditional Rendering with Components**

**Key Points**:

- Combine map and conditional logic for dynamic components.
- Pass props and use conditions inside child components.

**Code Example**:

```jsx
function StarRating({ rating }) {
  return (
    <div>
      {[...Array(5)].map((_, i) => (
        <span
          key={i}
          style={{ color: i < rating ? 'gold' : 'lightgray' }}>
          ★
        </span>
      ))}
    </div>
  )
}
```

This collection provides a solid foundation in JSX and React concepts, complete with practical code examples. Let me know if you need further elaboration!

---

## Components

>

### 1. **Root Component**

To set up a root in React:

1. Import `React` and `ReactDOM`.
2. Select the root element from your `HTML` document.
3. Use `ReactDOM.createRoot` and render the main component, typically `<App />`.

**Code Example:**

```jsx
import React from 'react'
import ReactDOM from 'react-dom/client'
import './index.css'
import App from './App'

const rootElement = document.getElementById('root')

ReactDOM.createRoot(rootElement).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
)
```

---

### 2. **Creating Components**

**Component Breakdown**

**Scenario:** Split an `App` component into sub-components (`Header` and `Form`).

1. Create individual files for each component.
2. Import and use these components within the `App` component.

**Code Example:**

- `App.jsx`:

  ```jsx
  import React from 'react'
  import Header from './Header'
  import Form from './Form'

  export default function App() {
    return (
      <div className='container'>
        <Header />
        <Form />
      </div>
    )
  }
  ```

- `Header.jsx`:

  ```jsx
  import React from 'react'

  export default function Header() {
    return (
      <header>
        <h1>Welcome</h1>
      </header>
    )
  }
  ```

- `Form.jsx`:

  ```jsx
  import React from 'react'

  export default function Form() {
    return (
      <form>
        <input
          type='email'
          placeholder='Email'
        />
        <input
          type='password'
          placeholder='Password'
        />
        <button type='submit'>Submit</button>
      </form>
    )
  }
  ```

---

### 3. **Purity and Side Effects**

A React component should be pure, meaning its output is predictable and depends solely on its input props.

**Example Issue:** A `Discussion` component incrementing a global counter results in unintended side effects due to React's rendering behavior.

**Solution:** Use props to pass data predictably.

```jsx
export default function Discussions() {
  return (
    <ul>
      <Discussion count={1} />
      <Discussion count={2} />
    </ul>
  )
}

function Discussion({ count }) {
  return <li>Discussion {count}</li>
}
```

---

### 4. **Lists and Keys**

React requires unique keys for lists to optimize rendering. Use `filter` and `map` for dynamically creating components.

**Code Example:**

```jsx
const projects = [
  { id: 1, name: 'Project A', isPinned: true },
  { id: 2, name: 'Project B', isPinned: false },
  { id: 3, name: 'Project C', isPinned: true },
]

export default function App() {
  return (
    <ul>
      {projects
        .filter(project => project.isPinned)
        .map(project => (
          <li key={project.id}>{project.name}</li>
        ))}
    </ul>
  )
}
```

---

### 5. **Fragments**

Fragments allow returning multiple elements without adding extra nodes to the DOM.

**Example:** Conditional rendering based on authentication.

```jsx
function Navbar({ isAuthUser }) {
  return (
    <div className='navbar-links'>
      {isAuthUser ? (
        <>
          <a href='/dashboard'>Dashboard</a>
          <a href='/logout'>Sign Out</a>
        </>
      ) : (
        <a href='/login'>Log In</a>
      )}
    </div>
  )
}
```

### **Key Takeaways:**

- Use `React.StrictMode` during development for identifying potential issues.
- Break down components into smaller, reusable units.
- Ensure components are pure and predictable.
- Use `filter`, `map`, and keys effectively when working with lists.
- Employ fragments to maintain clean and minimal DOM structure.

Let me know if you'd like to explore any of these sections further!

---

## Props

Here is a detailed summary of the React concepts and their solutions included in the provided notes:

### 1. **Props Basics**

- **Concept:** Props are a way to pass dynamic data to React components.
- **Example:**
  ```jsx
  <Avatar
    imageSrc='https://example.com/image.jpg'
    name='Tom Cook'
    profileText='See profile'
  />
  ```
  - Props (`imageSrc`, `name`, `profileText`) are passed as attributes to the `Avatar` component.
  - Inside the component, these props are accessed via the `props` object:
    ```jsx
    function Avatar(props) {
      return (
        <img
          src={props.imageSrc}
          alt={props.name}
        />
      )
    }
    ```

---

### 2. **Passing Props**

- **Task:** Customize a `FormInput` component dynamically.
- **Example:**
  ```jsx
  <FormInput
    id='email'
    type='email'
    label='Email'
    placeholder='you@example.com'
    message="We'll only use this for spam."
  />
  ```
- Inside the component:
  ```jsx
  function FormInput({ id, type, label, placeholder, message }) {
    return (
      <label htmlFor={id}>{label}</label>
      <input id={id} type={type} placeholder={placeholder} />
      <p>{message}</p>
    );
  }
  ```

---

### 3. **Props in Lists**

- **Task:** Use props and `map` to render a list dynamically.
- **Example:**
  ```jsx
  function PhotoList({ files }) {
    return (
      <ul>
        {files.map((file, index) => (
          <PhotoListItem
            key={index}
            file={file}
          />
        ))}
      </ul>
    )
  }
  ```
  - Pass each file object as a prop (`file`) to `PhotoListItem`.

---

### 4. **Destructuring Props**

- **Concept:** Simplify prop usage using object destructuring.
- **Example:**
  ```jsx
  function Card({ username, avatar, date, message }) {
    return (
      <div>
        <img
          src={avatar}
          alt={username}
        />
        <p>{username}</p>
        <p>{date}</p>
        <p>{message}</p>
      </div>
    )
  }
  ```
- Props are directly destructured in the function parameters.

---

### 5. **Children Props**

- **Concept:** Pass JSX as children for better composition.
- **Example:**
  ```jsx
  function BoxButton({ children }) {
    return <button className='box-button'>{children}</button>
  }
  ```
  Usage:
  ```jsx
  <BoxButton>
    <span>Click Me!</span>
  </BoxButton>
  ```

### **Best Practices**

1. **Naming Conventions:** Use camelCase for prop names to maintain consistency.
2. **Default Values:** Provide default values for props where applicable.
3. **Validation:** Use tools like PropTypes for type-checking props in large applications.
4. **Key Prop in Lists:** Always provide a `key` when rendering lists with `map`.

---

## State

>

### 1. **useState Hook**

The `useState` hook is fundamental in React for managing component-level state. It allows you to declare state variables and provides a function to update the state while ensuring React re-renders the component when the state changes.

#### Example: Tab Component

**Problem:** Toggle the appearance of tabs dynamically when clicked.

**Solution:**

1. Declare a `useState` variable to track the current tab.
2. Update the tab state using the setter function provided by `useState`.

```jsx
const [currentTab, setCurrentTab] = useState('Company')

return (
  <div>
    {tabs.map(tab => (
      <button
        key={tab}
        onClick={() => setCurrentTab(tab)}
        style={{
          backgroundColor: currentTab === tab ? 'blue' : 'white',
          color: currentTab === tab ? 'white' : 'black',
        }}>
        {tab}
      </button>
    ))}
  </div>
)
```

---

### 2. **Multiple State Variables**

For forms or components requiring multiple pieces of state, `useState` can be called multiple times.

#### Example: Personal Info Form

**Problem:** Manage `firstName`, `lastName`, and `timezone` inputs and disable the save button if any value is missing.

**Solution:**

1. Create separate state variables.
2. Update state with `onChange` handlers.

```jsx
const [firstName, setFirstName] = useState('')
const [lastName, setLastName] = useState('')
const [timezone, setTimezone] = useState('Eastern Time')

const isDisabled = !firstName || !lastName || !timezone

return (
  <form>
    <input
      value={firstName}
      onChange={e => setFirstName(e.target.value)}
      placeholder='First Name'
    />
    <input
      value={lastName}
      onChange={e => setLastName(e.target.value)}
      placeholder='Last Name'
    />
    <select
      value={timezone}
      onChange={e => setTimezone(e.target.value)}>
      <option value='Eastern Time'>Eastern Time</option>
      <option value='Pacific Time'>Pacific Time</option>
    </select>
    <button disabled={isDisabled}>Save</button>
  </form>
)
```

---

## 3. **Arrays in State**

Arrays in state can be manipulated using methods like `filter` and `map`. React ensures the UI updates when the state array changes.

#### Example: Order Summary

**Problem:** Remove products from an order summary when the trash button is clicked.

**Solution:**

1. Use `filter` to create a new array excluding the deleted product.
2. Update the state with the filtered array.

```jsx
const [products, setProducts] = useState(cartProducts)

const removeProduct = id => {
  setProducts(products.filter(product => product.id !== id))
}

return (
  <ul>
    {products.map(product => (
      <li key={product.id}>
        {product.name} - {product.price}
        <button onClick={() => removeProduct(product.id)}>Delete</button>
      </li>
    ))}
  </ul>
)
```

---

## 4. **Objects in State**

When managing state with objects, ensure immutability using the spread operator.

### Example: Update Billing Address

**Problem:** Update the country and postal code without affecting other properties in the object.

**Solution:**

1. Use the spread operator to copy the existing object and update only the changed fields.

```jsx
const [card, setCard] = useState({
  number: '1234',
  expiration: '12/24',
  country: 'USA',
  postalCode: '12345',
})

const updateBilling = e => {
  setCard({
    ...card,
    [e.target.name]: e.target.value,
  })
}

return (
  <div>
    <select
      name='country'
      onChange={updateBilling}
      value={card.country}>
      <option value='USA'>USA</option>
      <option value='Canada'>Canada</option>
    </select>
    <input
      name='postalCode'
      onChange={updateBilling}
      value={card.postalCode}
    />
  </div>
)
```

---

## 5. **Sharing State**

Sharing state requires "lifting state up" to a common parent and passing it down via props.

### Example: FAQ Accordion

**Problem:** Allow only one accordion to be open at a time.

**Solution:**

1. Move `isOpen` state to the parent component.
2. Pass the state and setter function to child components as props.

```jsx
const [selectedIndex, setSelectedIndex] = useState(null)

return (
  <dl>
    {faqs.map((faq, index) => (
      <Accordion
        key={index}
        isOpen={index === selectedIndex}
        onSelect={() => setSelectedIndex(index)}
        faq={faq}
      />
    ))}
  </dl>
)

function Accordion({ isOpen, onSelect, faq }) {
  return (
    <div>
      <button onClick={onSelect}>{faq.question}</button>
      {isOpen && <p>{faq.answer}</p>}
    </div>
  )
}
```

These examples provide a detailed roadmap for managing various React state scenarios, ensuring seamless and dynamic user experiences.

---

## Module 3: Advanced React

>

### **Overview**

Advanced React concepts elevate your development skills from beginner to well-rounded. This module focuses on handling complex topics that deepen understanding and enable mastery.

### **Key Topics**

>

#### 1. **Side Effects in React**

- **What are Side Effects?**
  - Operations that interact with the outside world (e.g., fetching data, updating DOM, logging).
- **Managing Side Effects with `useEffect`:**
  - **Purpose:** Handle effects such as fetching, subscriptions, or manual DOM updates.
  - **Execution Timing:**
    - After render by default.
    - Configurable via dependencies.
  - **Key Considerations:**
    - Avoid **infinite loops** by carefully managing the dependency array.
    - Clean up effects (e.g., remove event listeners) to avoid memory leaks.

#### 2. **Context API**

- **Purpose:** Share data across the component tree without prop drilling.
- **Components:**
  - **Provider:** Supplies the data.
  - **Consumer:** Accesses the data.
- **`useContext` Hook:**
  - Simplifies context consumption.
  - Reduces re-renders by focusing on relevant parts of the tree.
- **Optimization Tips:**
  - Minimize unnecessary updates in large trees.
  - Use memoization where necessary to enhance performance.

#### **Common Pitfalls and Solutions**

- **Infinite Loops in `useEffect`:**
  - Caused by mutable dependencies or improper setup.
  - **Solution:** Ensure dependencies are stable and correctly declared.
- **Over-rendering with Context:**
  - Excessive re-renders can reduce performance.
  - **Solution:** Restructure context or split into smaller providers.

#### **Additional Tips**

- Master debugging tools to troubleshoot React component behavior.
- Focus on writing clean and reusable code to simplify maintenance.

---

## Refs

>

### 1. **Media Playback**

**Problem:** Implement a video player using `useRef` for play/pause functionality, and display the video's current state.

**Key Steps:**

1. Use `useRef` to create a reference to the video element.
2. Connect the reference to the video element using the `ref` attribute.
3. Implement `play` and `pause` button handlers to control the video playback using the `play()` and `pause()` methods.
4. Display the video's current state (`Playing` or `Paused`) using event handlers (`onPlay`, `onPause`) and state management with `useState`.

**Code Example:**

```jsx
import React, { useRef, useState } from 'react'

function VideoPlayer() {
  const videoRef = useRef(null)
  const [isPlaying, setIsPlaying] = useState(false)

  function playVideo() {
    videoRef.current.play()
  }

  function pauseVideo() {
    videoRef.current.pause()
  }

  return (
    <div>
      <video
        ref={videoRef}
        src='example.mp4'
        onPlay={() => setIsPlaying(true)}
        onPause={() => setIsPlaying(false)}
        controls
      />
      <button onClick={playVideo}>Play</button>
      <button onClick={pauseVideo}>Pause</button>
      <div>{isPlaying ? 'Playing' : 'Paused'}</div>
    </div>
  )
}

export default VideoPlayer
```

---

### 2. **Input Focus**

**Problem:** Focus on an input element programmatically using a button.

**Key Steps:**

1. Use `useRef` to create a reference to the input element.
2. Connect the reference to the input element using the `ref` attribute.
3. Add a button with an `onClick` handler that calls the `focus()` method on the input element via the reference.

**Code Example:**

```jsx
import React, { useRef } from 'react'

function FocusInput() {
  const inputRef = useRef(null)

  function handleFocus() {
    inputRef.current.focus()
  }

  return (
    <div>
      <input
        ref={inputRef}
        type='text'
      />
      <button onClick={handleFocus}>Focus</button>
    </div>
  )
}

export default FocusInput
```

---

### 3. **Scroll To Element**

**Problem:** Scroll to a specific section of a page (e.g., pricing section) when a button is clicked.

**Key Steps:**

1. Use `useRef` to create a reference to the target element.
2. Connect the reference to the target section using the `ref` attribute.
3. Add a button with an `onClick` handler that calls the `scrollIntoView()` method.

**Code Example:**

```jsx
import React, { useRef } from 'react'

function ScrollToSection() {
  const pricingRef = useRef(null)

  function goToPricing() {
    pricingRef.current.scrollIntoView({ behavior: 'smooth' })
  }

  return (
    <div>
      <button onClick={goToPricing}>Go to Pricing</button>
      <div style={{ height: '100vh' }}>Hero Section</div>
      <div ref={pricingRef}>Pricing Section</div>
    </div>
  )
}

export default ScrollToSection
```

---

### 4. **Reference Values**

**Problem:** Use a `ref` to store a `setInterval` ID and implement a basic stopwatch.

**Key Steps:**

1. Use `useState` to track elapsed time.
2. Use `useRef` to store the `setInterval` ID.
3. Start the timer using `setInterval` and store the ID in the `ref`.
4. Stop the timer using `clearInterval` with the stored ID.

**Code Example:**

```jsx
import React, { useState, useRef } from 'react'

function Stopwatch() {
  const [seconds, setSeconds] = useState(0)
  const timerId = useRef(null)

  function startTimer() {
    timerId.current = setInterval(() => {
      setSeconds(prev => prev + 1)
    }, 1000)
  }

  function stopTimer() {
    clearInterval(timerId.current)
  }

  return (
    <div>
      <div>Elapsed Time: {seconds}s</div>
      <button onClick={startTimer}>Start</button>
      <button onClick={stopTimer}>Stop</button>
    </div>
  )
}

export default Stopwatch
```

---

### 5. **Refs and Rendering**

**Problem:** Fix a toggle component to work using `useState` instead of `useRef`.

**Key Steps:**

1. Replace `useRef` with `useState` to manage the toggle state.
2. Update the state using the `setState` function on toggle.

**Code Example:**

```jsx
import React, { useState } from 'react'

function Toggle() {
  const [enabled, setEnabled] = useState(false)

  function toggleSwitch() {
    setEnabled(prev => !prev)
  }

  return (
    <div>
      <button onClick={toggleSwitch}>{enabled ? 'Switch ON' : 'Switch OFF'}</button>
    </div>
  )
}

export default Toggle
```

These examples showcase the use of `useRef` and `useState` in practical scenarios, covering various interactive UI features in React.

---

## Effects

>

### 1. **useEffect hook**

>

#### Using `useEffect` for Side Effects

The `useEffect` hook in React allows you to perform side effects in function components. Examples include fetching data, directly manipulating the DOM, or interacting with browser APIs.

#### **Example 1: Updating Document Title**

Use `document.title` to reflect the number of button clicks.

**Code:**

```jsx
import React, { useState, useEffect } from 'react'

function Counter() {
  const [count, setCount] = useState(0)

  useEffect(() => {
    document.title = `You clicked ${count} times`
  })

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>Click me</button>
    </div>
  )
}

export default Counter
```

**Explanation:**

- The `useEffect` hook runs after every render by default.
- `document.title` is updated based on the `count` state, creating a dynamic tab title.

---

### 2. **Dependency Array**

The dependency array controls when the `useEffect` hook is executed. Without it, the hook runs on every render.

#### **Example: Avoiding Infinite Loops**

Prevent an infinite loop caused by state updates within `useEffect`.

**Code:**

```jsx
useEffect(() => {
  setCount(count + 1) // Infinite loop without dependencies array
}, [value]) // Runs only when 'value' changes
```

**Explanation:**

- Adding `[value]` ensures the effect only runs when `value` changes, synchronizing state effectively.

---

### 3. **Synchronizing with State**

Use `useEffect` to synchronize a modal component's visibility with state.

**Code:**

```jsx
import React, { useState, useRef, useEffect } from 'react'

function App() {
  const [isOpen, setIsOpen] = useState(false)
  const dialogRef = useRef()

  useEffect(() => {
    if (isOpen) {
      dialogRef.current.showModal()
    } else {
      dialogRef.current.close()
    }
  }, [isOpen])

  return (
    <div>
      <button onClick={() => setIsOpen(true)}>Open Modal</button>
      <dialog ref={dialogRef}>
        <h1>Modal is open!</h1>
        <button onClick={() => setIsOpen(false)}>Close</button>
      </dialog>
    </div>
  )
}

export default App
```

**Explanation:**

- Synchronizes `isOpen` state with the modal visibility.
- Uses `useRef` to manage the `dialog` element without re-rendering.

---

### 4. **Fetching Data with `useEffect`**

Fetch and display data using the `useEffect` hook.

**Code:**

```jsx
import React, { useState, useEffect } from 'react'

function Todos() {
  const [todos, setTodos] = useState([])

  useEffect(() => {
    fetch('https://jsonplaceholder.typicode.com/users/1/todos')
      .then(response => response.json())
      .then(data => setTodos(data))
  }, [])

  return (
    <div>
      {todos.map(todo => (
        <div key={todo.id}>
          <input
            type='checkbox'
            defaultChecked={todo.completed}
          />
          {todo.title}
        </div>
      ))}
    </div>
  )
}

export default Todos
```

**Explanation:**

- Fetch data once when the component mounts (`[]` dependency array).
- Store and render todos dynamically.

---

### **5. Cleanup Function (in `useEffect`)**

Perform cleanup operations like removing event listeners or intervals to avoid memory leaks or errors.

**Code:**

```jsx
import React, { useState, useEffect } from 'react'

function MouseTracker() {
  const [position, setPosition] = useState({ x: 0, y: 0 })

  useEffect(() => {
    function handleMove(e) {
      setPosition({ x: e.clientX, y: e.clientY })
    }
    window.addEventListener('pointermove', handleMove)

    return () => {
      window.removeEventListener('pointermove', handleMove) // Cleanup
    }
  }, [])

  return (
    <div>
      <p>
        Mouse Position: {position.x}, {position.y}
      </p>
    </div>
  )
}

export default MouseTracker
```

**Explanation:**

- The cleanup function prevents state updates on unmounted components.
- Removes event listeners, improving performance and preventing errors.

### **Key Takeaways**

- `useEffect` handles side effects, such as interacting with external APIs or DOM manipulation.
- Use the dependency array to control when the effect runs.
- Always perform cleanup when adding listeners or similar side effects to prevent memory leaks.
- Combine `useEffect` with state to synchronize React components with external systems.

Let me know if you need further clarifications or additions to these notes!

---

## Context

### **React Context API: Comprehensive Guide with Examples**

>

#### What is Context in React?

Context allows you to share data across components in a React app without the need to pass props manually down the tree. This helps avoid "prop drilling" and makes state management more efficient.

### 1. **Creating Context**

To create a context:

1. Use the `createContext` function from React.
2. Assign it a default value.

**Example:**

```jsx
import React, { createContext } from 'react'

// Create a context with a default value
const SaleContext = createContext('40%')

export default SaleContext
```

---

### 2. **Consuming Context**

To use the context value within a component, use the `useContext` hook.

**Example:**

```jsx
import React, { useContext } from 'react'
import SaleContext from './SaleContext'

function Hero() {
  const percentOff = useContext(SaleContext)
  return <h1>{`Get everything ${percentOff} off!`}</h1>
}

export default Hero
```

---

### 3. **Context Provider**

Wrap the components that need access to the context with the Provider component. Pass the desired value through the `value` prop.

**Example:**

```jsx
import React from 'react'
import SaleContext from './SaleContext'
import Hero from './Hero'

function App() {
  return (
    <SaleContext.Provider value='50%'>
      <Hero />
    </SaleContext.Provider>
  )
}

export default App
```

---

### **Advanced Patterns: Managing Authentication State**

>

#### **Auth Context Example**

Here’s how to manage authentication state with context:

**Creating AuthContext:**

```jsx
import React, { createContext } from 'react'

const AuthContext = createContext(false) // Default is unauthenticated

export default AuthContext
```

**Using AuthContext in Components:**

```jsx
import React, { useContext } from 'react'
import AuthContext from './AuthContext'

function Links() {
  const isAuthenticated = useContext(AuthContext)

  return (
    <nav>
      {isAuthenticated ? (
        <ul>
          <li>Dashboard</li>
          <li>Team</li>
          <li>Projects</li>
        </ul>
      ) : (
        <ul>
          <li>Login</li>
        </ul>
      )}
    </nav>
  )
}
```

**Providing AuthContext:**

```jsx
import React, { useState } from 'react'
import AuthContext from './AuthContext'
import Links from './Links'

function App() {
  const [isAuthenticated, setIsAuthenticated] = useState(false)

  return (
    <AuthContext.Provider value={isAuthenticated}>
      <Links />
      <button onClick={() => setIsAuthenticated(!isAuthenticated)}>
        {isAuthenticated ? 'Logout' : 'Login'}
      </button>
    </AuthContext.Provider>
  )
}

export default App
```

---

### 4. **(Avoiding) Props Drilling**

Instead of passing props through multiple layers of components, context can simplify this process.

#### Before Context (Prop Drilling):

```jsx
function App() {
  const session = { name: 'Alex', initials: 'AB' }

  return <Header session={session} />
}

function Header({ session }) {
  return <Avatar session={session} />
}

function Avatar({ session }) {
  return <span>{session.name}</span>
}
```

#### After Context:

```jsx
const SessionContext = createContext()

function App() {
  const session = { name: 'Alex', initials: 'AB' }

  return (
    <SessionContext.Provider value={session}>
      <Header />
    </SessionContext.Provider>
  )
}

function Header() {
  return <Avatar />
}

function Avatar() {
  const session = useContext(SessionContext)

  return <span>{session.name}</span>
}
```

---

### 5. **Updating Context**

Context can also handle updates by combining it with state.

#### Example: Logging Out a User

**Setup Context with State:**

```jsx
const SessionContext = createContext()

function App() {
  const [session, setSession] = useState({ name: 'Alex', initials: 'AB' })

  const onLogout = () => setSession(null)

  return (
    <SessionContext.Provider value={{ session, onLogout }}>
      <Header />
    </SessionContext.Provider>
  )
}
```

**Consume and Update Context:**

```jsx
function Avatar() {
  const { session, onLogout } = useContext(SessionContext)

  if (!session) return null

  return (
    <div>
      <span>{session.name}</span>
      <button onClick={onLogout}>Logout</button>
    </div>
  )
}
```

### **Key Takeaways**

1. **Creation**: Use `createContext` to set up shared data.
2. **Consumption**: Use `useContext` to access the data.
3. **Provider**: Wrap components with a `Provider` to supply the data.
4. **Updates**: Combine context with state for dynamic data handling.
5. **Avoiding Prop Drilling**: Use context to simplify passing data across nested components.

This guide offers a solid foundation for understanding and implementing React Context in your applications. For more complex patterns, consider exploring context reducers or libraries like Redux for state management.

---

## Reducers

### 1. **useReducer Hook**

The `useReducer` hook in React is a powerful alternative to `useState` for managing complex state logic.

It follows the reducer pattern from functional programming and is often used to consolidate state logic.

#### **Basic Syntax**

```jsx
const [state, dispatch] = useReducer(reducer, initialState)
```

- **reducer**: A function that determines the next state based on the current state and the action.
- **initialState**: The initial value of the state.

---

### 2. **Pass data with useReducer**

>

#### Counter Example with `useReducer`

**Problem:** Increment a counter when a button is clicked. Throw an error for unrecognized action types.

##### **Code Example**

```jsx
import React, { useReducer } from 'react'

function reducer(state, action) {
  if (action.type === 'increment') {
    return state + 1
  } else {
    throw new Error('Unrecognized action type')
  }
}

function Counter() {
  const [count, dispatch] = useReducer(reducer, 0)

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => dispatch({ type: 'increment' })}>Increment</button>
    </div>
  )
}
```

#### Managing Form Inputs

**Problem:** Use `useReducer` to manage a form that invites users. The state should store user email, and an action with type "invite" should handle form submission.

##### **Code Example**

```jsx
function reducer(state, action) {
  if (action.type === 'invite') {
    return action.data
  } else {
    throw new Error('Unrecognized action type')
  }
}

function InviteUser() {
  const [user, dispatch] = useReducer(reducer, null)

  function handleInviteUser(event) {
    event.preventDefault()
    const formData = new FormData(event.currentTarget)
    const email = formData.get('email')
    if (typeof email === 'string') {
      dispatch({
        type: 'invite',
        data: { email },
      })
      event.target.reset()
    }
  }

  return (
    <div>
      <form onSubmit={handleInviteUser}>
        <input
          type='email'
          name='email'
          placeholder='Enter email'
        />
        <button type='submit'>Invite</button>
      </form>
      {user && <p>Invited User: {user.email}</p>}
    </div>
  )
}
```

---

### 3. **Multiple Action Types**

**Problem:** Manage a list of users where you can add and delete users using separate actions.

#### **Code Example**

```jsx
function usersReducer(users, action) {
  if (action.type === 'add') {
    return [...users, action.data]
  } else if (action.type === 'delete') {
    return users.filter(user => user.name !== action.data.name)
  } else {
    throw new Error('Unrecognized action type')
  }
}

function ManageUsers() {
  const [users, dispatch] = useReducer(usersReducer, [])

  function handleAddUser(event) {
    event.preventDefault()
    const formData = new FormData(event.currentTarget)
    const name = formData.get('name')
    if (typeof name === 'string') {
      dispatch({ type: 'add', data: { name } })
      event.target.reset()
    }
  }

  function handleDeleteUser(userToDelete) {
    dispatch({ type: 'delete', data: userToDelete })
  }

  return (
    <div>
      <form onSubmit={handleAddUser}>
        <input
          type='text'
          name='name'
          placeholder='Enter user name'
        />
        <button type='submit'>Add User</button>
      </form>
      <ul>
        {users.map((user, index) => (
          <li key={index}>
            {user.name}
            <button onClick={() => handleDeleteUser(user)}>Delete</button>
          </li>
        ))}
      </ul>
    </div>
  )
}
```

### **Key Points**

1. **Action Objects:** Actions dispatched to a reducer are objects with a `type` property, and optionally other data.

   ```jsx
   { type: 'action_type', data: { key: value } }
   ```

2. **Reducer Function:** The reducer must be a pure function that computes the next state.

   ```jsx
   function reducer(state, action) {
     switch (action.type) {
       case 'ACTION_TYPE':
         return newState
       default:
         throw new Error('Unknown action type')
     }
   }
   ```

3. **Complex State Management:** `useReducer` is ideal for managing state involving multiple sub-values or when next state depends on the previous state.

These examples provide a clear understanding of the flexibility and power of the `useReducer` hook, with detailed use cases for practical application.

---

## Module 4: TypeScript for React

**Intro**

- Transition from plain JavaScript to TypeScript in React applications.
- Benefits: Enhanced security and reliability through static typing.
- Approach: Step-by-step integration from no types to comprehensive typing.

**Core Objectives**

- Basics of using TypeScript with React components.
- Understanding and implementing types for:
  - Props
  - Children props
  - HTML props
- Combining types with key React hooks.

### **Detailed Topics**

1. **Getting Started with TypeScript in React**

   - Setting up a TypeScript-enabled React project.
   - Differences between JavaScript and TypeScript in a React context.

2. **TypeScript and React Components**

   - Adding types to React components.
   - Defining and using props with interfaces and types.
   - Typing children and ensuring type safety.

3. **Handling HTML Props**

   - Passing standard HTML attributes with proper types.
   - Leveraging `React.HTMLAttributes` and other helper types.

4. **React Hooks with TypeScript**
   - Using hooks effectively with type definitions:
     - `useState` – Defining state types.
     - `useEffect` – Handling dependencies and inferred types.
     - `useRef` – Typing references for elements and values.
     - `Context` – Setting up strongly typed context providers and consumers.
     - `useReducer` – Typing actions and reducers for state management.

### **Practical Examples and Exercises**

1. Starting with a basic React component in TypeScript.
2. Gradually adding types for:
   - Props and state.
   - Children components.
   - Hook usage.
3. Debugging common TypeScript issues in React projects.

---

## Introduction to TypeScript

>

### 1. **Component Files**

>

#### **Problem**

To work with TypeScript in a React application, you need to update file extensions and configurations. Specifically, you must adjust component files to the appropriate TypeScript format.

#### **Key Points**

**File Extensions**:

- React component files that use JSX should end with `.tsx`.
- Non-JSX TypeScript files should use the `.ts` extension.

**Opt-In Nature**:

- TypeScript is not mandatory for all files. You can opt-in where types are beneficial and use plain JavaScript elsewhere.

#### **Example: Updating `App.js` to `App.tsx`**

>

#### Before (`App.js`)

```javascript
// App.js
import React from 'react'

function App() {
  return <div>Hello, TypeScript</div>
}

export default App
```

#### After (`App.tsx`)

```typescript
// App.tsx
import React from 'react'

const App: React.FC = () => {
  return <div>Hello, TypeScript</div>
}

export default App
```

**Changes Made**:

- Renamed the file from `App.js` to `App.tsx`.
- Used `React.FC` to add a type annotation for a functional component.

### **Key Observations**

1. **JSX Files in TypeScript**:
   - Files containing React components must end in `.tsx` to use JSX syntax.
2. **Seamless Transition**:

   - Changing the file extension to `.tsx` doesn't break existing functionality.

3. **Configuration**:
   - When using a framework like `Create React App` with the TypeScript template, most configurations are pre-set.

### **React Component TypeScript Template**

For a more structured component:

```typescript
import React, { FC } from 'react'

interface AppProps {
  title?: string
}

const App: FC<AppProps> = ({ title }) => {
  return <div>{title || 'Hello, TypeScript'}</div>
}

export default App
```

---

### 2. **Type Information**

**Problem:**  
You have an `input` element in a TypeScript file that lacks two properties: `size` and `onChange`. Your task is to determine their expected data types and properly implement them in the code.

#### **Solution Steps**

1. **Hover to Reveal Type Information**  
   In VS Code, hover over the properties (`size` and `onChange`) to access their type definitions.

2. **Interpret the Type Definitions**

   - **`size`**:
     - Type: `number | undefined`
     - This means `size` can either be a numeric value or `undefined` (optional).
   - **`onChange`**:
     - Type: `(event: ChangeEvent<HTMLInputElement>) => void | undefined`
     - Accepts a function that handles change events for an input element or is `undefined`.

3. **Use Union and Type Annotations**  
   Use the revealed type annotations to correct the implementation.

---

#### **Code Example**

>

#### Before:

```tsx
<input />
```

#### After:

```tsx
import React, { ChangeEvent } from 'react'

function App() {
  const handleChange = (event: ChangeEvent<HTMLInputElement>) => {
    console.log(event.target.value) // Logs the value typed into the input
  }

  return (
    <input
      size={20} // Assign a numeric value for size
      onChange={handleChange} // Pass a valid function for handling change events
    />
  )
}

export default App
```

### **Key Takeaways**

- **Hover for Types:** In VS Code with TypeScript, hovering over properties or parts of the code reveals detailed type definitions.
- **Leverage TypeScript:** You don’t need external documentation for most type-related questions; the editor provides comprehensive type hints.
- **Union Types:** Properties like `onChange` can accept multiple types (`void | undefined` in this case), enabling flexibility in implementation.

### **Benefits of TypeScript**

- Clear understanding of expected data types in real time.
- Enhanced error-checking with squiggly lines in VS Code indicating type mismatches.
- Inline documentation through type hints.

---

Here are some notes and code examples based on the transcript for using TypeScript's autocomplete feature effectively:

---

### 3. **Type Autocomplete**

#### **Why Use TypeScript Autocomplete?**

- To explore available properties of HTML elements (e.g., `<span>`).
- To understand associated types without guessing or relying on external resources.
- To enhance productivity by leveraging TypeScript's built-in type definitions.

#### **Steps to Explore Properties of an HTML Element**

1. **Basic Typing for Suggestions**

- Begin typing any letter inside an element (e.g., `<span>`).
- Example:
  ```tsx
  <span a  // Start typing, and you'll get autocomplete suggestions.
  ```
- This will show all the potential properties, even uncommon ones.

2. **Shortcut for Full Property List**

- Use `Ctrl + Space` (or `Cmd + Space` on Mac) for a comprehensive list.
- Example:
  ```tsx
  <span
      // Press Ctrl + Space here to view all available attributes.
  >
  ```

3. **Hover for Definitions**

- Hover over an element or property to see its type information.
- Example:
  ```tsx
  const badge = <span className='badge'></span>
  // Hover over `badge` to see its type.
  ```

4. **Jump to Type Definitions**

- Hold `Ctrl` (or `Cmd` on Mac) and click the element to jump to its type definition file (`index.d.ts`).
- Example:
  ```tsx
  <span onClick={() => console.log('clicked')}></span>
  // Ctrl/Cmd-click `onClick` to view its type definition.
  ```

#### **Where Do the Types Come From?**

- Type definitions are globally available through `.d.ts` files.
- React types, including HTML attributes, are sourced from `node_modules`.

### **Code Example**

Here’s a practical example to explore and apply the mentioned techniques:

```tsx
import React from 'react'

function Badge() {
  return (
    <span
      id='badge-id'
      className='badge'
      onClick={() => alert('Badge clicked!')}
      // Try typing here or using Ctrl + Space to see all properties.
    >
      Hover for details
    </span>
  )
}

export default Badge
```

### **Key Tips**

- **Global Types:** Most HTML attribute types for React elements are globally available.
- **Autocomplete:** Use `Ctrl + Space` or type partial names to narrow down attributes.
- **Definition Files:** Use `Ctrl + Click` to explore `.d.ts` files for deeper insights.

#### **Conclusion**

TypeScript autocomplete significantly reduces the need to search online for information about element attributes and types. Practice these techniques to improve your TypeScript coding workflow.

---

## Types

>

### 1. **Basic Types**

#### **Introduction to Type Annotations**

TypeScript introduces type annotations to JavaScript, allowing you to specify the expected type for variables, function parameters, and return values. This reduces runtime errors by catching type mismatches during development.

Example:

```typescript
let message: string = 'Hello, TypeScript!'
console.log(typeof message) // Output: "string"
```

---

#### **Common Data Types**

TypeScript supports many types corresponding to JavaScript's data types:

1. **String**: Represents text data.
   ```typescript
   let name: string = 'Alice'
   ```
2. **Number**: Represents numeric values.
   ```typescript
   let age: number = 25
   ```
3. **Boolean**: Represents `true` or `false`.
   ```typescript
   let isStudent: boolean = true
   ```
4. **Undefined**: A variable with no assigned value.
5. **Null**: Explicitly represents an empty or non-existent value.

---

#### **Using Type Annotations**

##### **Scenario: Fixing Errors in Type Annotations**

Consider a TypeScript application with variables used in a UI component. Incorrect type annotations cause errors.

###### **Variables**

- `className`: Should always be a `string`.
- `width`: Can be a `number` or a numeric string.
- `disabled`: Should accept a `boolean` or `undefined`.

###### **Initial Problematic Code**

```typescript
let className: number = 'button-class' // Error
let width: string = 200 // Error
let disabled: boolean = 'false' // Error
```

##### **Solution**

Correct the annotations to align with expected types:

```typescript
let className: string = 'button-class' // Correct
let width: number = 200 // Correct
let disabled: boolean = false // Correct
```

###### **Component Integration Example**

```tsx
function Badge() {
  let className: string = 'badge'
  let width: number = 200
  let disabled: boolean = false

  return (
    <span
      className={className}
      style={{ width: `${width}px` }}
      aria-disabled={disabled}>
      Badge Text
    </span>
  )
}
```

---

#### **Key Lessons**

1. **Error Prevention**: Type annotations help catch errors at development time, reducing bugs.
   ```typescript
   let count: string = 10 // TypeScript error: Type 'number' is not assignable to type 'string'.
   ```
2. **Explicit Typing**: Adding explicit types clarifies the developer's intent, aiding collaboration.
3. **Type Checking with JSX**: In React/JSX, TypeScript ensures type compatibility for props.

#### **Exploring Advanced Types**

1. **Union Types**: Allow variables to hold multiple types.
   ```typescript
   let size: number | string = 200 // Can be a number or string
   ```
2. **Custom Types**: Define reusable type structures.
   ```typescript
   type BadgeProps = {
     className: string
     width: number
     disabled: boolean
   }
   ```

By applying these principles, TypeScript improves code reliability and maintainability.

---

### 2. **Object Types**

Object types are used to define the structure of objects, including arrays and plain objects. This ensures type safety and helps with error checking during development.

---

#### **Annotating Arrays**

To annotate an array type, you can use one of two methods:

**Example: Using Bracket Syntax**

```typescript
let options: string[] = ['Option1', 'Option2', 'Option3']
```

**Example: Using `Array` Generic**

```typescript
let options: Array<string> = ['Option1', 'Option2', 'Option3']
```

**Note:** TypeScript often infers types automatically (type inference). While annotations can be redundant, they are helpful for clarity and learning.

---

#### **Custom Types for Objects**

Custom types can be created using the `type` keyword or `interface`.

##### **Using `type` Keyword**

```typescript
type Location = {
  id: string
  name: string
  defaultValue: string
  disabled: boolean
}

const location: Location = {
  id: 'loc1',
  name: 'New York',
  defaultValue: 'NY',
  disabled: false,
}
```

##### **Using `interface` Keyword**

```typescript
interface Location {
  id: string
  name: string
  defaultValue: string
  disabled: boolean
}

const location: Location = {
  id: 'loc1',
  name: 'New York',
  defaultValue: 'NY',
  disabled: false,
}
```

### **Key Points to Remember**

1. **Custom Type Naming Convention**: Always start type names with a capital letter (e.g., `Location`).
2. **Type Syntax for Objects**:
   - Use semicolons (`;`) to separate properties, not commas.
   - Commas may not work or may be auto-converted to semicolons by your formatter.
3. **Type Inference**: Often, TypeScript can infer types without explicit annotations, but explicit types can make code more readable and predictable.
4. **`type` vs. `interface`**:
   - `type` uses `=` to assign structure.
   - `interface` omits `=`.

---

Here’s a note summarizing the key concepts from your provided file with relevant code examples:

---

### 3. **Optional Types**

>

### **Making Function Parameters Optional**

To make a function parameter optional in TypeScript, you use the `?` syntax after the parameter name. This automatically includes `undefined` in the type union, indicating that the parameter may or may not be provided.

#### Example:

```typescript
function getCharacter(id?: string | number): void {
  console.log(`Fetching character with ID: ${id ?? 1}`)
}
```

**Explanation**:

- `id?: string | number` makes `id` optional.
- If `id` is not provided, `undefined` will be passed. Using `id ?? 1` ensures a fallback value of `1`.

### **Specifying Function Return Types**

You can specify the return type of a function using a colon (`:`) followed by the type. For asynchronous functions, the return type is usually a `Promise` with a type argument.

#### Example: Synchronous Function

```typescript
function getGreeting(): string {
  return 'Hello, Luke Skywalker!'
}
```

- The return type is explicitly defined as `string`.

#### Example: Asynchronous Function

```typescript
async function getCharacterDetails(id: string | number): Promise<string> {
  return `Details for character with ID: ${id}`
}
```

- `Promise<string>` indicates the function resolves to a string after the `Promise` resolves.

### **Key Concepts in Practice**

#### Defining `getCharacter`

```typescript
async function getCharacter(id?: string | number): Promise<void> {
  const characterId = id ?? 1 // Default to 1 if no ID is provided
  console.log(`Fetching details for character with ID: ${characterId}`)

  // Example API call simulation
  const characterName = await fetch(`https://swapi.dev/api/people/${characterId}/`)
    .then(response => response.json())
    .then(data => data.name)
    .catch(() => 'Unknown Character')

  console.log(`Character Name: ${characterName}`)
}
```

**Features**:

1. The `id` parameter is optional.
2. The function return type is `Promise<void>` because it doesn't explicitly return any value.

### **Common TypeScript Scenarios**

1. **Union Types**: Allows specifying multiple types for a variable or parameter.

   ```typescript
   let id: string | number = '1' // Can be either a string or a number
   ```

2. **Default Values**: Use the nullish coalescing operator (`??`) to provide a fallback.

   ```typescript
   const characterId = id ?? 1 // Use 1 if `id` is undefined or null
   ```

3. **Async/Await**: For asynchronous operations, ensure the return type is a `Promise` with the correct resolved value.

---

## Typed Components

### 1. **Typed Props**

**Problem**: Define the props passed to the `Person` component using an interface to resolve type errors.

**Solution**:

- Create an interface (e.g., `PersonProps`) to define the props' structure and types.
- Example:

  ```tsx
  interface PersonProps {
    name: string
    avatar: string
    width: number
    height: number
  }

  const Person: React.FC<PersonProps> = ({ name, avatar, width, height }) => {
    return <div>{/* Render component */}</div>
  }
  ```

- Alternatives:
  - Inline types directly in the function parameter.
  - Use `type` instead of `interface`.

---

### 2. **Typed Optional Props**

**Problem**: Replace the `any` type in a `Section` component and make the `cover` prop optional.

**Solution**:

- Use a question mark (`?`) to make props optional in the interface.
- Example:

  ```tsx
  interface SectionProps {
    heading: string
    cover?: string
    text: string
  }

  const Section: React.FC<SectionProps> = ({ heading, cover, text }) => {
    return (
      <section style={{ background: cover || 'black' }}>
        <h1>{heading}</h1>
        <p>{text}</p>
      </section>
    )
  }
  ```

---

### 3. **Typed Children**

**Problem**: Properly type the `children` prop for a `CallToAction` component.

**Solution**:

- Use `React.ReactNode` to type the `children` prop.
- Example:

  ```tsx
  interface CallToActionProps {
    children?: React.ReactNode
  }

  const CallToAction: React.FC<CallToActionProps> = ({ children }) => {
    return <a>{children || 'Click me'}</a>
  }
  ```

---

### 4. **Typed Event Handlers**

**Problem**: Type the `handleClose` prop for a `Details` component.

**Solution**:

- Use `React.MouseEventHandler<HTMLButtonElement>` for button click handlers.
- Example:

  ```tsx
  interface DetailsProps {
    handleClose: React.MouseEventHandler<HTMLButtonElement>
  }

  const Details: React.FC<DetailsProps> = ({ handleClose }) => {
    return <button onClick={handleClose}>Close</button>
  }
  ```

---

### 5. **Typed HTML Props**

**Problem**: Modify a `Button` component to accept native HTML props like a standard button element.

**Solution**:

- Use `React.ComponentProps<'button'>` to inherit the native button props.
- Example:

  ```tsx
  type ButtonProps = React.ComponentProps<'button'>

  const Button: React.FC<ButtonProps> = props => {
    return <button {...props} />
  }
  ```

---

### Key Notes:

- **Interface vs. Type**: Interfaces are better for defining objects, while `type` is more flexible for unions or primitive types.
- **Optional Props**: Use `propName?: type` to make props optional.
- **Children Prop**: Use `React.ReactNode` for flexible children content.
- **Event Handlers**: Use specific handler types (e.g., `React.MouseEventHandler<Element>`).
- **Native HTML Props**: Use `React.ComponentProps<'elementName'>` for intrinsic element properties.

---

## Typed Hooks

>

### 1. **Typed `useState`**

>

#### Problem:

A `useState` hook is used to manage an array of objects representing to-dos. Without a type argument, TypeScript infers the type incorrectly, leading to errors.

#### Solution:

- Add a type argument to `useState`.
- Define a type for the to-do structure.

#### Example:

```tsx
interface Todo {
  id: number
  text: string
}

const [todos, setTodos] = useState<Todo[]>([])

const addTodo = (text: string) => {
  setTodos(prev => [...prev, { id: Date.now(), text }])
}
```

---

### 2. **Typed `useEffect`**

>

#### Problem:

Using `setInterval` within `useEffect` caused a type error when its return value was incorrectly handled.

#### Solution:

- Ensure `useEffect` returns a cleanup function or nothing.
- Store the interval ID in a variable and clean it up.

#### Example:

```tsx
useEffect(() => {
  const timer = setInterval(() => {
    console.log('Count up')
  }, 1000)

  return () => clearInterval(timer) // Cleanup function
}, [])
```

---

### 3. **Typed `useRef`**

>

#### Problem:

Using `useRef` for an input element without specifying the type leads to TypeScript errors.

#### Solution:

- Provide an explicit type argument for `useRef`.
- Handle potential `null` values before accessing properties.

#### Example:

```tsx
const inputRef = useRef<HTMLInputElement | null>(null)

useEffect(() => {
  inputRef.current?.focus()
}, [])

return <input ref={inputRef} />
```

---

### 4. **Typed Context**

>

#### Problem:

The context value is inferred as `unknown`, causing type errors when accessed.

#### Solution:

- Define a type for the context.
- Use it with `createContext`.

#### Example:

```tsx
interface User {
  username: string
}

const UserContext = createContext<User | null>(null)

const App = () => {
  const [currentUser, setCurrentUser] = useState<User | null>({ username: 'JohnDoe' })

  return (
    <UserContext.Provider value={currentUser}>
      <Profile />
    </UserContext.Provider>
  )
}

const Profile = () => {
  const user = useContext(UserContext)

  if (!user) return null

  return <p>{user.username}</p>
}
```

---

### 5. **Typed `useReducer`**

>

#### Problem:

The `useReducer` implementation lacked type definitions, leading to runtime errors.

#### Solution:

- Define types for the `state` and `action` parameters.
- Use these types in the reducer.

#### Example:

```tsx
interface State {
  views: number
}

type Action = { type: 'increment'; payload: number } | { type: 'decrement'; payload: number }

const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case 'increment':
      return { views: state.views + action.payload }
    case 'decrement':
      return { views: state.views - action.payload }
    default:
      return state
  }
}

const [state, dispatch] = useReducer(reducer, { views: 0 })
```

---

## Module 5: Next.js Mastery

#### **1. Introduction**

- Focus on building seamless user experiences.
- Learn to structure pages and implement layout components for consistency.

#### **2. Client and Server Components**

- **Client Components**: Ideal for:
  - Form submissions
  - State management
  - Event handling
- **Server Actions**:
  - Perform server-side data mutations.
  - Eliminate the need for separate client components.

#### **3. Data Fetching**

- Explore various methods to fetch and display data.
- Utilize route handlers to manage HTTP requests (e.g., publishing, deleting posts).

#### **4. Dynamic Routes**

- Enable personalized, data-driven experiences.
- Use dynamic routing with template literals and route parameters.

#### **5. Styling Techniques**

- Leverage CSS Modules:
  - Encapsulate styles within components.
  - Create clean and maintainable code.

#### **6. Static Pages**

- Develop efficient, pre-rendered pages.
- Enhance performance through optimized static content.

#### **7. Database Integration with Prisma**

- Perform CRUD operations seamlessly.
- Gain insights into data modeling and management.

#### **8. Server Actions**

- Execute server-side functions dynamically.
- Enhance web application performance and interactivity.

---

## Getting Started

### 1. **Project Overview**

- **Objective**: Build a full-stack microblogging application with TypeScript and Next.js.
- **Features**:
  - CRUD functionality (Create, Read, Update, Delete).
  - Markdown-based post creation.
  - Posts can be saved as drafts, published, or deleted.
  - Published posts appear on the homepage.
- **Database**: Managed using Prisma.

---

### 2. **Tools Needed**

- **Node.js** (minimum version 18): Download from [nodejs.org](https://nodejs.org).
  - Verify installation using `node -v`.
  - Includes NPM (Node Package Manager) for managing dependencies.
- **Visual Studio Code (VS Code)**: Recommended code editor. Download from [code.visualstudio.com](https://code.visualstudio.com).

---

### 3. **Why Next.js?**

- **Advantages over React**:
  - Built-in functionalities for routing, metadata management, and server-side rendering.
  - Improved SEO and performance.
  - Tools for font loading, CSS handling, and image optimization.
- **Server-Side Capabilities**:
  - Enables server-side rendering and data fetching.
  - Enhances app scalability and SEO.
- **Official Resources**:
  - Comprehensive documentation: [Next.js Docs](https://nextjs.org/docs).

---

### 4. **Setting Up a Next.js Project**

- **Command**: `npx create-next-app@latest`
- **Configuration Steps**:
  1. Name the project (e.g., `microblog`).
  2. Use TypeScript (Yes).
  3. Enable ESLint (Yes).
  4. Skip Tailwind CSS (No, using CSS modules instead).
  5. Use the "app" router (Yes).
  6. Do not customize the import alias (No).
- **Dependencies Installed**:
  - `next`, `react`, `react-dom`, TypeScript, ESLint, and their associated libraries.
- **Project Structure**: Open in VS Code and familiarize yourself with the files and folders.

---

### 5. **Files and Folders Overview**

### Important Files:

- **`package.json`**: Contains scripts (e.g., `npm run dev`) and dependencies.
- **`next.config.js`**: Configuration file for features like redirects and experimental options.
- **`.gitignore`**: Lists files and folders to exclude from version control (e.g., `node_modules`, `.next`).
- **`next-env.d.ts`**: Required for TypeScript setup (do not modify).
- **`.eslintrc.json`**: Configure linting rules.

### Key Folders:

- **`public`**: Static assets (e.g., images, fonts). Access via a forward slash (e.g., `/image.png`).
- **`pages`**: Core folder for page components (e.g., `index.tsx` for the homepage).
  - Pages must export a default React component.
  - Supports route creation and server-side API endpoints.

---

### 6. **Running the Project**

- Open the terminal in VS Code (`Ctrl`/`Cmd` + `~` or View > Terminal).
- Start the development server: `npm run dev`.
- Access the project at `http://localhost:3000`.
- **Initial Cleanup**:
  - Remove default JSX and styles from the homepage.
  - Clear unnecessary files (e.g., `page.module.css`).
  - Prepare a blank slate for the microblogging app.

### Next Steps

- Begin building the microblogging app by structuring the homepage and implementing core features (CRUD, Markdown support, database integration).

---

## Pages & Components

### 1. **Root Layout in Next.js**

- The **root layout** in Next.js acts as the main component encapsulating all pages.
- Found in `app/layout.tsx` when using the App Router.
- It provides functionalities like:
  - Wrapping pages with common components (e.g., `Navbar`, `Footer`).
  - Maintaining state consistency across pages.

#### Example: Layout File

```tsx
// app/layout.tsx
export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang='en'>
      <head />
      <body>{children}</body>
    </html>
  )
}
```

- Use the `children` prop to include all page content dynamically.

### 2. **Styling in Next.js**

Next.js supports various styling approaches:

- **Global CSS:** Applied universally across pages (e.g., `globals.css`).
- **CSS Modules:** Scoped to individual components, avoiding naming conflicts.

#### Example: Global CSS

```css
/* globals.css */
body {
  font-family: 'Arial', sans-serif;
  margin: 0;
  padding: 0;
}
```

#### Example: CSS Module

```css
/* navbar.module.css */
.nav {
  background-color: #333;
  color: white;
}
```

```tsx
// components/Navbar.tsx
import styles from './navbar.module.css'

export default function Navbar() {
  return (
    <nav className={styles.nav}>
      <a href='/'>Home</a>
    </nav>
  )
}
```

### 3. **Client vs Server Components**

- **Server Components** are rendered on the server by default, optimizing SEO and performance.
- To use client-side features (e.g., state, hooks), declare a component as a **Client Component**:
  - Add `'use client';` at the top of the file.

#### Example: Client Component

```tsx
'use client'

import { useState } from 'react'

export default function Counter() {
  const [count, setCount] = useState(0)

  return <button onClick={() => setCount(count + 1)}>Count: {count}</button>
}
```

### 4. **Dynamic Routing with Links**

- Use the `next/link` component for client-side routing.

#### Example: Navbar with Links

```tsx
// components/Navbar.tsx
import Link from 'next/link'

export default function Navbar() {
  return (
    <nav>
      <Link href='/'>Home</Link>
      <Link href='/about'>About</Link>
    </nav>
  )
}
```

### 5. **Static vs Dynamic Pages**

- **Static Pages:** No data fetching; content does not change frequently.
- **Dynamic Pages:** Fetch and render data dynamically.

#### Example: Static Page

```tsx
// app/about/page.tsx
export const metadata = {
  title: 'About Us',
  description: 'Learn more about our project.',
}

export default function AboutPage() {
  return (
    <main>
      <h1>About Us</h1>
      <p>We are a team passionate about building modern web applications.</p>
    </main>
  )
}
```

#### Example: Dynamic Page

```tsx
// app/posts/page.tsx
export default async function PostsPage() {
  const posts = await fetch('https://jsonplaceholder.typicode.com/posts').then(res => res.json())

  return (
    <main>
      <h1>Posts</h1>
      <ul>
        {posts.map(post => (
          <li key={post.id}>{post.title}</li>
        ))}
      </ul>
    </main>
  )
}
```

### **Using Metadata**

- Override metadata for specific pages for better SEO.

#### Example: Metadata in Page

```tsx
// app/about/page.tsx
export const metadata = {
  title: 'About Us',
  description: 'Details about our project.',
}
```

### **Common Practices**

- **Component Organization:**
  - Place reusable components in a `components` directory.
  - Use `import` paths configured in `tsconfig.json`.
- **Styling Approach:**
  - Use CSS Modules for scoped styles.
  - Use global styles sparingly for consistent app-wide rules.

---

## Data Fetching

>

### 1. **Prisma Setup**

Prisma is a powerful tool for working with databases in a type-safe and user-friendly manner.

#### Steps to Set Up Prisma:

1. **Install Prisma CLI**:
   ```bash
   npm install prisma --save-dev
   ```
2. **Initialize Prisma**:

   ```bash
   npx prisma init --data-source-provider sqlite
   ```

   This creates:

   - A `prisma` folder.
   - `schema.prisma`: Define data models here.
   - `.env`: Contains database connection details.

3. **Define Models** (e.g., User and Post models):

   ```prisma
   model User {
     id    Int     @id @default(autoincrement())
     email String  @unique
     name  String?
     posts Post[]
   }

   model Post {
     id        Int      @id @default(autoincrement())
     createdAt DateTime @default(now())
     updatedAt DateTime @updatedAt
     title     String
     content   String?
     published Boolean  @default(false)
     author    User     @relation(fields: [authorId], references: [id])
     authorId  Int
   }
   ```

4. **Apply Migrations**:

   ```bash
   npx prisma migrate dev
   ```

5. **Generate Prisma Client**:
   Use the client for querying:

   ```javascript
   import { PrismaClient } from '@prisma/client'
   const prisma = new PrismaClient()

   const users = await prisma.user.findMany()
   console.log(users)
   ```

---

### 2. **API Route Handlers**

Using Prisma with Next.js API routes to fetch and manipulate data.

1. **Create an API Route**:
   File: `app/api/posts/route.ts`

   ```javascript
   import { PrismaClient } from '@prisma/client'
   import { NextResponse } from 'next/server'

   const prisma = new PrismaClient()

   export async function GET() {
     const posts = await prisma.post.findMany({
       where: { published: true },
       include: { author: true },
     })
     return NextResponse.json(posts)
   }
   ```

2. **Fetch Data from Frontend**:

   ```javascript
   const res = await fetch('/api/posts')
   const posts = await res.json()
   ```

3. **Cache Control with Next.js**:
   ```javascript
   const res = await fetch('/api/posts', {
     next: { revalidate: 10 }, // Revalidate every 10 seconds
   })
   ```

---

### 3. **React Server Components**

Using Prisma with React Server Components for server-side rendering.

1. **Fetch Data in Server Component**:

   ```javascript
   import { PrismaClient } from '@prisma/client'

   const prisma = new PrismaClient()

   export default async function Posts() {
     const posts = await prisma.post.findMany({
       where: { published: true },
       include: { author: true },
     })

     return (
       <div>
         {posts.map(post => (
           <div key={post.id}>
             <h2>{post.title}</h2>
             <p>By {post.author?.name}</p>
           </div>
         ))}
       </div>
     )
   }
   ```

2. **TypeScript Support**:
   Prisma automatically generates TypeScript types for your models.

---

### 4. **Client-Side Data Fetching**

For components requiring interactivity (e.g., forms).

1. **Form Submission with Client Components**:

   ```javascript
   'use client'

   import { useState } from 'react'

   export default function SignupForm() {
     const [formData, setFormData] = useState({ name: '', email: '' })

     const handleSubmit = async e => {
       e.preventDefault()
       await fetch('/api/signup', {
         method: 'POST',
         body: JSON.stringify(formData),
         headers: { 'Content-Type': 'application/json' },
       })
     }

     return (
       <form onSubmit={handleSubmit}>
         <input
           type='text'
           placeholder='Name'
           value={formData.name}
           onChange={e => setFormData({ ...formData, name: e.target.value })}
         />
         <input
           type='email'
           placeholder='Email'
           value={formData.email}
           onChange={e => setFormData({ ...formData, email: e.target.value })}
         />
         <button type='submit'>Sign Up</button>
       </form>
     )
   }
   ```

---

### 5. **Server Actions (Experimental)**

Efficient server-side form handling with experimental features in Next.js.

1. **Enable Server Actions**:
   In `next.config.js`:

   ```javascript
   module.exports = {
     experimental: { serverActions: true },
   }
   ```

2. **Using Server Actions**:

   ```javascript
   'use server'

   import { redirect } from 'next/navigation'
   import { PrismaClient } from '@prisma/client'

   const prisma = new PrismaClient()

   export async function submitAction(formData) {
     const name = formData.get('name')
     const email = formData.get('email')

     if (name && email) {
       await prisma.user.create({ data: { name, email } })
       redirect('/')
     }
   }
   ```

   Form example:

   ```javascript
   export default function SignupPage() {
     return (
       <form action={submitAction}>
         <input
           type='text'
           name='name'
           placeholder='Name'
         />
         <input
           type='email'
           name='email'
           placeholder='Email'
         />
         <button type='submit'>Sign Up</button>
       </form>
     )
   }
   ```

These notes provide a structured guide to Prisma setup, API route handlers, React Server Components, client-side data fetching, and server actions with examples to make implementation easier.

---

## App Content

### 1. **Create Post Page**

#### Steps:

1. **Create a Folder and Page**:

   - Add a `Create` folder under `app`.
   - Add `page.tsx` to export the `CreatePostsPage` component.

2. **Form UI**:

   - Use a `<form>` containing:
     - Title Input: `<input name="title" placeholder="Title" type="text" />`
     - Email Input: `<input name="email" placeholder="Author Email Address" type="email" />`
     - Content Text Area: `<textarea name="content" placeholder="Content" cols="50" rows="8"></textarea>`
     - Submit Button: `<button type="submit">Create Post</button>`
     - Cancel Link: `<a href="/">Cancel</a>`

3. **Add Styles**:

   - Create `create-post.module.css` with styles (e.g., margin for the "Cancel" link).
   - Import the styles in `page.tsx`.

4. **Handle Form Submission**:

   - Create `submitAction` as an async server function:

     ```typescript
     import { PrismaClient } from '@prisma/client'
     const prisma = new PrismaClient()

     async function submitAction(formData: FormData) {
       const title = formData.get('title')?.toString()
       const email = formData.get('email')?.toString()
       const content = formData.get('content')?.toString()

       if (!title) return

       await prisma.post.create({
         data: {
           title,
           content,
           author: { connect: { email } },
         },
       })

       redirect('/drafts')
     }
     ```

   - Bind `submitAction` to the form with `action={submitAction}`.

---

### 2. **Drafts Page**

#### Steps:

1. **Page Creation**:

   - Add `Drafts` folder under `app` with `page.tsx`.
   - Render drafts using:

     ```typescript
     async function DraftsPage() {
       const drafts = await prisma.post.findMany({ where: { published: false } })

       return (
         <main>
           <h1>Drafts</h1>
           {drafts.map(draft => (
             <div
               key={draft.id}
               className={styles.draft}>
               <Post {...draft} />
             </div>
           ))}
         </main>
       )
     }
     ```

2. **Styling**:
   - Add `drafts.module.css` with styles for draft cards, hover effects, and spacing.

---

### 3. **Dynamic Page Routes**

#### Steps:

1. **Dynamic Route Setup**:

   - Add `posts/[postId]` folder under `app`.
   - Create `page.tsx`:

     ```typescript
     async function PostPage({ params }: { params: { postId: string } }) {
       const post = await prisma.post.findUnique({ where: { id: parseInt(params.postId) } })
       if (!post) notFound()

       return <PostDetails {...post} />
     }
     ```

2. **Render Markdown Content**:

   - Install `markdown-to-jsx`: `npm i markdown-to-jsx`.
   - Use in `PostDetails` component:

     ```typescript
     import Markdown from 'markdown-to-jsx'

     function PostDetails({
       title,
       content,
       author,
     }: {
       title: string
       content: string
       author: string
     }) {
       return (
         <main>
           <h1>{title}</h1>
           <p>By {author}</p>
           <Markdown>{content}</Markdown>
         </main>
       )
     }
     ```

---

### 4. **Dynamic Route Handlers**

#### Steps:

1. **Folder Structure**:

   - Add `api/posts/[postId]` under `app`.

2. **Handle PUT Requests**:

   ```typescript
   export async function PUT(req, { params }) {
     const postId = parseInt(params.postId)
     await prisma.post.update({ where: { id: postId }, data: { published: true } })
     return new Response('Post published', { status: 200 })
   }
   ```

3. **Handle DELETE Requests**:

   ```typescript
   export async function DELETE(req, { params }) {
     const postId = parseInt(params.postId)
     await prisma.post.delete({ where: { id: postId } })
     return new Response('Post deleted', { status: 200 })
   }
   ```

4. **Client-Side Buttons**:

   ```typescript
   function PostDetails({ id, title }) {
     const publishPost = async () => {
       await fetch(`/api/posts/${id}`, { method: 'PUT' })
       window.location.reload()
     }

     const deletePost = async () => {
       await fetch(`/api/posts/${id}`, { method: 'DELETE' })
       window.location.reload()
     }

     return (
       <main>
         <h1>{title}</h1>
         <button onClick={publishPost}>Publish</button>
         <button onClick={deletePost}>Delete</button>
       </main>
     )
   }
   ```

---
