---
sidebar_position: 7
---

# React 2025

---

## Module 1: JavaScript to React

### **Purpose**

This module is designed to equip learners with the essential JavaScript knowledge required for React development. It emphasizes focusing on relevant aspects of JavaScript without needing to master the entire language.

### **Key Learning Areas**

1. **Functions as Reusable Components**

   - Understanding functions as modular and reusable "slices" of the user interface.
   - Leveraging functions to build dynamic and flexible applications.

2. **Control Flow with Conditionals**

   - Using conditionals to manage application behavior.
   - Dynamically controlling what the user sees and determining code execution paths.

3. **Sharing Code with Modules**

   - Organizing code by sharing functions and variables.
   - Leveraging JavaScript modules for cleaner, more maintainable code.

4. **Mastering Objects and Arrays**

   - Efficiently creating and manipulating object and array structures.
   - Utilizing advanced array methods for dynamic data handling.

5. **Asynchronous Programming**
   - Working with asynchronous operations using Promises.
   - Mastering the `async/await` syntax for handling real-time data and API interactions.

### **Why This Matters**

React is deeply intertwined with JavaScript; improving JavaScript proficiency inherently enhances React development skills.

### **Conclusion**

The module emphasizes practical JavaScript skills directly applicable to building robust React applications. By mastering these key areas, learners will develop a solid foundation for creating efficient and scalable React apps.

---

## Functions

### 1. **Functions as UI**

To dynamically update UI content, use JavaScript functions and template literals.

#### Problem

Display "Hello Python" using the `getLanguage` function.

#### Key Concepts

- Use template literals with backticks (`` ` ``) for dynamic content.
- Embed variables using `${}`.
- Ensure the function returns the intended string.

#### Solution Code

```javascript
function getLanguage() {
  return 'Python'
}

document.body.innerHTML = `<h1>Hello ${getLanguage()}</h1>`
```

#### Notes

- Without `return`, the function outputs `undefined`.
- Ensure the function is called, not referenced (`getLanguage()` vs `getLanguage`).

---

### 2. **Function Arguments**

Create dynamic UI elements by passing arguments to functions.

#### Problem

Make the button text dynamic.

#### Key Concepts

- Use arguments in functions to modify content dynamically.
- Inline styles and additional arguments can enhance reusability.

#### Solution Code

```javascript
function createButton(action) {
  return `<button>${action} video</button>`
}

document.body.innerHTML = `
    ${createButton('Like')}
    ${createButton('Dislike')}
`
```

#### Notes

- Use additional arguments for styles:
  ```javascript
  function createButton(action, style) {
    return `<button style="${style}">${action} video</button>`
  }
  ```

---

### 3. **Function Composition**

Combine multiple components to build a functional UI (e.g., video player).

#### Problem

Create a video player with a header, video, and buttons.

#### Key Concepts

- Compose functions for headers, videos, and buttons.
- Pass arguments for attributes like `src`, `style`, etc.

#### Solution Code

```javascript
function createHeader(title) {
  return `<h1>Watch ${title}</h1>`
}

function createVideo(src, height = '300px', width = '100%') {
  return `<video src="${src}" controls style="height:${height}; width:${width};"></video>`
}

function createButton(action, color) {
  return `<button style="background-color:${color};">${action} video</button>`
}

document.body.innerHTML = `
    ${createHeader('Big Buck Bunny')}
    ${createVideo('big_buck_bunny.mp4')}
    <div style="margin-top: 20px;">
        ${createButton('Like', 'green')}
        ${createButton('Dislike', 'red')}
    </div>
`
```

#### Notes

- Styles can be applied dynamically through arguments.
- Encapsulate UI logic in reusable functions.

---

### 4. **Passing Arguments**

Break markup into reusable components.

#### Problem

Split the page into components for the title and cover image.

#### Key Concepts

- Pass arguments for properties like `src`, `height`, `width`.
- Provide fallback values using default parameters.

#### Solution Code

```javascript
function createTitle(title) {
  return `<h1>${title}</h1>`
}

function createCoverImage(src, height = '300px', width = '520px') {
  return `<img src="${src}" style="height:${height}; width:${width};"/>`
}

document.body.innerHTML = `
    ${createTitle('My Computer Setup')}
    ${createCoverImage('cover.jpg')}
`
```

#### Notes

- Default parameters handle missing arguments.
- Fallback values prevent broken UI when arguments are missing.

---

### 5. **Passing Objects as Arguments**

Simplify argument management by using objects.

#### Problem

Pass all profile data as a single object.

#### Key Concepts

- Use objects to group related data.
- Access properties using `object.property`.

#### Solution Code

```javascript
const profileProps = {
  src: 'profile.jpg',
  name: 'John Doe',
}

function createProfile(props) {
  return `
        <div>
            <img src="${props.src}" alt="Profile Picture"/>
            <h2>${props.name || 'Anonymous'}</h2>
        </div>
    `
}

document.body.innerHTML = createProfile(profileProps)
```

#### Notes

- Provide fallback values using `||`.
- Consolidates data into a single, manageable structure.

---

### **Summary**

- **Template Literals:** For dynamic HTML content.
- **Function Arguments:** Increase flexibility.
- **Function Composition:** Build reusable, modular UI components.
- **Default Parameters:** Provide fallback values.
- **Object Arguments:** Simplify and structure data passing.

These practices align with modern JavaScript principles and ease the transition to frameworks like React.

---

## Conditionals

### 1. **If Statements**

#### Problem

Write a conditional that:

- Displays `"authenticated content"` if the user is authenticated (`isAuth` is `true`).
- Displays `"Log in here"` if `isAuth` is `false`.

#### Solution

```javascript
if (isAuth) {
  console.log('authenticated content')
} else {
  console.log('Log in here')
}
```

#### Explanation

- The `if` condition checks if `isAuth` is true.
- If true, it executes the block that shows authenticated content.
- Otherwise, it falls back to the `else` block and displays the unauthenticated message.

---

### 2. **Ternary Expressions**

#### Problem

Rewrite the above conditional using a ternary operator.

#### Solution

```javascript
console.log(isAuth ? 'authenticated content' : 'Log in here')
```

#### Explanation

- The ternary operator `?` is a concise alternative to `if-else`.
- Syntax: `condition ? expression_if_true : expression_if_false`.

---

### 3. **Nested Ternaries**

#### Problem

Display the user's avatar if it exists; otherwise, display a default avatar.

#### Solution

```javascript
const avatarSrc = user.avatar ? user.avatar : defaultAvatar
console.log(`<img src="${avatarSrc}" width="100px" alt="User Avatar">`)
```

**Shortened Version Using OR (`||`):**

```javascript
const avatarSrc = user.avatar || defaultAvatar
console.log(`<img src="${avatarSrc}" width="100px" alt="User Avatar">`)
```

#### Explanation

- `user.avatar` is checked for truthiness. If it exists, its value is used.
- The `||` operator provides a fallback when the first value is falsy.

---

### 4. **Hide Content**

#### Problem

1. Hide all markup if `user.avatar` is not present.
2. Hide only the avatar if `user.avatar` is not present.

#### Solution

**1. Hide All Markup**

```javascript
if (!user.avatar) {
  return '' // Return an empty string or null to hide all markup
}
```

**2. Hide Only the Avatar**

```javascript
const avatarMarkup = user.avatar ? `<img src="${user.avatar}" alt="User Avatar">` : ''
console.log(`<div>${avatarMarkup}</div>`)
```

#### Explanation

- Use an early return for hiding all content.
- Use a ternary operator to selectively hide/show specific elements.

---

### 5. **Conditional Styles**

#### Problem

Change the `DownloadButton`:

- If `isPaid` is `true`: Add the `.paid` class with the text `"Buy Now"`.
- If `isPaid` is `false`: Use a green background with the text `"Download Free"`.

#### Solution

```javascript
const buttonClass = `download-button ${props.isPaid ? 'paid' : ''}`.trim()
const buttonText = props.isPaid ? 'Buy Now' : 'Download Free'

console.log(`<button class="${buttonClass}">${buttonText}</button>`)
```

#### Explanation

- Use a template literal to dynamically add or omit the `paid` class.
- Use a ternary operator for conditional text.
- `.trim()` ensures no extra spaces if the class is empty.

---

### **Key Notes**

- **Ternaries**: Ideal for concise conditions but avoid deep nesting to maintain readability.
- **Early Returns**: Simplify conditionals by returning early for exceptional cases.
- **Conditional Classes**: Combine base classes with dynamic ones using template literals or class libraries (like `classnames` in React).

These examples cover practical applications for JavaScript conditionals, useful for React and other frameworks.

---

## Arrays

---

### 1. **Display Content with Map**

Using `map` to Transform and Display Arrays

#### Problem

Transform a list of features from HTML content into an array and display each as a list item dynamically.

#### Steps

1. Extract text from HTML list items.
2. Store the texts as elements in an array named `features`.
3. Use the `.map()` function to generate `<li>` elements.

#### Example Code

```javascript
const features = ['Feature 1', 'Feature 2', 'Feature 3']

const featureList = features.map(feature => `<li>${feature}</li>`).join('')
document.querySelector('ul#features').innerHTML = featureList
```

---

### 2. **Transform Arrays with Map**

Mapping Arrays of Objects to Components

#### Problem

Use an array of objects to display details (e.g., team members) as HTML components.

#### Steps

1. Create an array of objects containing member details (e.g., `name`, `role`, `imageUrl`).
2. Use `.map()` to iterate and generate HTML.
3. Avoid unnecessary properties (e.g., `twitterUrl`, `linkedinUrl`).

#### Example Code

```javascript
const members = [
  { name: 'Alice', role: 'Developer', imageUrl: 'alice.jpg' },
  { name: 'Bob', role: 'Designer', imageUrl: 'bob.jpg' },
]

const memberHTML = members
  .map(
    member => `
  <div class="member">
    <img src="${member.imageUrl}" alt="${member.name}">
    <h3>${member.name}</h3>
    <p>${member.role}</p>
  </div>
`
  )
  .join('')
document.querySelector('.members').innerHTML = memberHTML
```

---

### 3. **Filtering Arrays with `filter`**

#### Problem

Separate an array of links into "Support" and "Company" categories based on the path.

#### Steps

1. Use `.filter()` to extract relevant links for each category.
2. Use `.map()` to generate and display HTML for the filtered results.

#### Example Code

```javascript
const links = [
  { href: '/support/pricing', text: 'Pricing' },
  { href: '/support/documentation', text: 'Documentation' },
  { href: '/company/about', text: 'About Us' },
]

const supportLinks = links.filter(link => link.href.startsWith('/support'))
const companyLinks = links.filter(link => link.href.startsWith('/company'))

const supportHTML = supportLinks.map(link => `<a href="${link.href}">${link.text}</a>`).join('')
const companyHTML = companyLinks.map(link => `<a href="${link.href}">${link.text}</a>`).join('')

document.querySelector('#support-links').innerHTML = supportHTML
document.querySelector('#company-links').innerHTML = companyHTML
```

---

### 4.**Map with Inner Function**

Nested Lists with `map` and `filter`

#### Problem

Filter vegetarian recipes and display their names along with a nested list of ingredients.

#### Steps

1. Use `.filter()` to include only vegetarian recipes.
2. Use `.map()` to create HTML for the recipes and their ingredients.

#### Example Code

```javascript
const recipes = [
  { name: 'Salad', isVegetarian: true, ingredients: ['Lettuce', 'Tomato', 'Cucumber'] },
  { name: 'Burger', isVegetarian: false, ingredients: ['Bun', 'Beef', 'Cheese'] },
]

const vegetarianRecipes = recipes.filter(recipe => recipe.isVegetarian)

const recipeHTML = vegetarianRecipes
  .map(
    recipe => `
  <div class="recipe">
    <h3>${recipe.name}</h3>
    <ul>
      ${recipe.ingredients.map(ingredient => `<li>${ingredient}</li>`).join('')}
    </ul>
  </div>
`
  )
  .join('')

document.querySelector('#recipes').innerHTML = recipeHTML
```

---

### 5.**Nested Lists**

Displaying Conditional Content with Ternaries\*\*

#### Problem

Use a boolean property (e.g., `done`) to conditionally render content for each item in a todo list.

#### Steps

1. Use `.map()` to iterate over the todo list.
2. Include a ternary operator to render different content based on the `done` property.

#### Example Code

```javascript
const todos = [
  { text: 'Buy groceries', done: true },
  { text: 'Clean house', done: false },
]

const todoHTML = todos
  .map(
    todo => `
  <li>
    <span>${todo.done ? '✅' : '❌'}</span> 
    <span>${todo.text}</span>
  </li>
`
  )
  .join('')

document.querySelector('#todo-list').innerHTML = todoHTML
```

---

### **Key Notes on `map` and `filter`**

- **`map()`**: Transforms each element of an array into a new array.
- **`filter()`**: Returns a new array containing elements that satisfy a condition.
- Use **template literals** (``) for clean inline HTML generation.
- Use **`.join('')`** after `map` to remove commas when rendering strings.

These examples incorporate common practices in React and JavaScript, making them suitable for both beginner and advanced learners.

---

## Objects

### 1. **Destructuring**

#### **Problem**

Destructure `id`, `label`, and `defaultChecked` from an object passed to a `Checkbox` component and use these variables appropriately.

#### **Solution**

```jsx
function Checkbox({ id, label, defaultChecked }) {
  return (
    <div>
      <input
        type='checkbox'
        id={id}
        defaultChecked={defaultChecked}
      />
      <label htmlFor={id}>{label}</label>
    </div>
  )
}
```

**Explanation:**

- `id` is used for the `id` attribute.
- `label` is the label text displayed.
- `defaultChecked` determines the checkbox's initial state.

---

### 2. **Rest Operator**

#### **Problem**

Destructure the `src` property from the object passed to an `Avatar` component. Use the rest operator to gather other properties.

#### **Solution**

```jsx
function Avatar({ src, ...rest }) {
  return (
    <img
      src={src}
      alt={rest.alt}
      style={{ borderRadius: rest.borderRadius }}
    />
  )
}
```

**Explanation:**

- `src` is destructured for the `src` attribute.
- `...rest` gathers remaining properties like `alt` and `borderRadius`.

---

### 3. **Default Values**

#### **Problem**

Provide default fallback values for missing properties:

- `author`: "Someone"
- `text`: "No message"
- `time`: ""

#### **Solution**

```jsx
function Message({ author = 'Someone', text = 'No message', time = '' }) {
  return (
    <div>
      <strong>{author}</strong> commented {time}
      <p>{text}</p>
    </div>
  )
}
```

**Explanation:**

- Default values are specified in the destructuring assignment to handle missing data gracefully.

---

### 4. **Spread Operator**

#### **Problem**

Add properties from a `livesIn` object to each user and display their location.

#### **Solution**

```jsx
const users = [
  { name: 'John', email: 'john@example.com' },
  { name: 'Jane', email: 'jane@example.com' },
]

const livesIn = { state: 'California', country: 'USA' }

const updatedUsers = users.map(user => ({
  ...user,
  ...livesIn,
}))

updatedUsers.forEach(user => {
  console.log(`${user.name} lives in ${user.state}, ${user.country}`)
})
```

**Explanation:**

- The spread operator is used to merge `user` and `livesIn`.

---

### 5. **Nested Spread Operator**

#### **Problem**

Add a `today` property to the nested `record` property in a stats object.

#### **Solution**

```jsx
const stats = [
  { id: 1, record: { name: 'Subscribers', value: 1200 } },
  { id: 2, record: { name: 'Open Rate', value: 75 } },
]

const updatedStats = stats.map(stat => ({
  ...stat,
  record: {
    ...stat.record,
    date: 'today',
  },
}))

updatedStats.forEach(stat => {
  console.log(`${stat.record.name}: ${stat.record.value} as of ${stat.record.date}`)
})
```

**Explanation:**

- The first spread operator copies `stat`.
- The nested spread operator copies and updates `record`.

---

### **General Notes**

1. **Destructuring**: Extracts specific properties for cleaner and more readable code.
2. **Rest Operator**: Gathers remaining properties into an object, useful for flexible handling of additional attributes.
3. **Default Values**: Provides fallback values to ensure components handle missing props gracefully.
4. **Spread Operator**: Combines or extends objects and arrays efficiently, avoiding mutation.
5. **Nested Spread Operator**: Updates deeply nested structures while maintaining immutability.

## Promises

### 1. **Promise Chaining and Fetch API**

#### Problem: Display the Count of Star Wars Characters

Use the Fetch API to retrieve data and display the count value in the UI.

#### Code Example

```javascript
fetch('https://swapi.dev/api/people/')
  .then(response => response.json()) // Parse the JSON response
  .then(data => {
    const count = data.count
    document.getElementById('characters').textContent = count // Update UI
  })
  .catch(error => console.error('Error:', error))
```

#### Key Points

- **`fetch`** returns a promise.
- Use **`.then()`** to handle the response and parse JSON.
- Update the DOM with the retrieved data.

---

### 2. **Error Handling with Promises**

#### Problem: Handle Fetch Errors and Update UI

Check the `.ok` property of the response to detect request errors.

#### Code Example

```javascript
fetch('https://swapi.dev/api/people/')
  .then(response => {
    if (!response.ok) {
      throw new Error('Error making request')
    }
    return response.json()
  })
  .then(data => {
    document.getElementById('characters').textContent = data.count
  })
  .catch(error => {
    console.error(error)
    document.getElementById('error-message').textContent = 'Could not fetch data.'
  })
```

#### Key Points

- Check `.ok` to confirm the request succeeded.
- Use **`.catch()`** for error handling.

---

### 3. **Finally Callback**

#### Problem: Cleanup After Promise Resolution

Use `.finally()` to remove a loading indicator.

#### Code Example

```javascript
const loadingElement = document.getElementById('loading')

fetch('https://swapi.dev/api/people/')
  .then(response => response.json())
  .then(data => {
    document.getElementById('characters').textContent = data.count
  })
  .catch(error => {
    console.error('Error:', error)
  })
  .finally(() => {
    loadingElement.remove() // Remove loading indicator
  })
```

#### Key Points

- `.finally()` is called regardless of success or failure.
- Ideal for cleanup operations like hiding spinners.

---

### 4. **Async/Await Syntax**

#### Problem: Simplify Promise Handling

Replace `.then()` chains with `async/await`.

#### Code Example

```javascript
async function fetchCharacters() {
  try {
    const response = await fetch('https://swapi.dev/api/people/')
    if (!response.ok) {
      throw new Error('Error making request')
    }
    const data = await response.json()
    document.getElementById('characters').textContent = data.count
  } catch (error) {
    console.error(error)
    document.getElementById('error-message').textContent = 'Could not fetch data.'
  } finally {
    document.getElementById('loading').remove()
  }
}

fetchCharacters()
```

#### Key Points

- Use `await` for promises to maintain a synchronous-like flow.
- Wrap `await` calls in `try/catch` for error handling.
- `finally` is used for cleanup.

---

### 5. **Complete Async/Await Solution**

#### Problem: Display Star Wars Film Count

Use `async/await`, handle errors, and clean up the UI.

#### Code Example

```javascript
async function fetchFilms() {
  try {
    const response = await fetch('https://swapi.dev/api/films/')
    if (!response.ok) {
      throw new Error('Error fetching films')
    }
    const data = await response.json()
    document.getElementById('films').textContent = data.count
  } catch (error) {
    console.error(error)
    document.getElementById('error-message').textContent = 'Error fetching films.'
  } finally {
    document.getElementById('loading').remove()
  }
}

fetchFilms()
```

#### Challenge

- Modify the example to display a list of film titles in the UI.

These notes provide a solid foundation for understanding and working with promises and `async/await`.

## Module 2: React Essentials

#### Introduction

- **Focus**: Understanding the building blocks and dynamics of React after grasping JavaScript fundamentals.
- **Key Areas**:
  - Elements vs. Plain HTML.
  - JSX and its integration with JavaScript.

---

#### Building Blocks of React

1. **React Elements**:

   - Core components of React.
   - Similarities and differences with HTML elements.

2. **JSX (JavaScript XML)**:
   - Appears unusual but offers dynamic capabilities by combining HTML-like syntax with JavaScript.

---

#### React Components

- **Custom Elements**:

  - Built using React components.
  - Resemble JavaScript functions with specific quirks.

- **Key Features**:
  - Handle DOM rendering.
  - Require predictable data inputs (props).
  - Output only JSX without side effects.

---

#### Data Handling with Props

- **Props**:
  - Enable dynamic behavior in components.
  - Facilitate data flow into components.
  - Patterns include:
    - **Prop Destructuring**: Extracting values for simpler usage.
    - **Composition with `children` Prop**: Building nested or reusable components.

---

#### Managing State in React

- **State**:

  - Represents the "memory" of a React application.
  - Tracks data across a component's lifecycle.

- **Key Concepts**:

  - **useState Hook**: Initialize and update local state.
  - Handling multiple state variables.
  - Using arrays and objects as state variables.

- **Patterns**:
  - **Lifting State Up**: Share state between components.

---

## Elements

### 1. **HTML to JSX**

**Key Points**:

- JSX is syntactically similar to HTML but adheres to JavaScript rules.
- Use `className` instead of `class`.
- Close self-closing tags with `/>`.
- Wrap all JSX elements within a single parent element.

**Code Example**:

```jsx
export default function Pricing() {
  return (
    <div>
      <h2 className='title'>Simple no-tricks pricing</h2>
      <hr />
      <a
        href='/buy'
        className='button'>
        Buy Now <span aria-hidden='true'>→</span>
      </a>
    </div>
  )
}
```

---

### 2. **Dynamic Data with Curly Braces**

**Key Points**:

- Use curly braces `{}` to insert JavaScript expressions in JSX.
- Access properties dynamically from objects or variables.

**Code Example**:

```jsx
const bannerData = {
  version: 4,
  icon: <Icon />,
  href: '/new',
}

export default function Banner() {
  return (
    <div>
      <h2>What's new in version {bannerData.version}</h2>
      <a href={bannerData.href}>{bannerData.icon}</a>
    </div>
  )
}
```

---

### 3. **Inline Styles**

**Key Points**:

- Inline styles in JSX are objects, with camelCased property names.
- Use double curly braces `{{}}` to define styles.

**Code Example**:

```jsx
<button style={{ backgroundColor: 'green', color: 'white' }}>Create</button>
<button style={{ backgroundColor: 'darkorange', color: 'white' }}>Update</button>
<button style={{ backgroundColor: 'red', color: 'white', fontWeight: 'bold' }}>Delete</button>
```

---

### 4. **Conditionals in JSX**

**Key Points**:

- Use ternary operators or logical operators (`&&`) for conditional rendering.
- Return `null` to hide components.

**Code Example**:

```jsx
const isSaleOpen = true

export default function SaleBanner() {
  return (
    <div>
      <h2>{isSaleOpen ? 'Sale is On!' : 'Sale has Ended'}</h2>
      {isSaleOpen && <a href='/sale'>Shop Now</a>}
    </div>
  )
}
```

---

### 5. **Hiding Elements**

**Key Points**:

- Use early returns to hide components entirely.
- Conditional rendering based on variables or expressions.

**Code Example**:

```jsx
const review = { author: 'John', rating: 4, content: 'Great product!' }

export default function Review() {
  if (!review.author) return null

  const isGoodReview = review.rating >= 4

  return (
    <div>
      <h4>{review.author}</h4>
      <p>{isGoodReview ? review.content : 'No review'}</p>
      {isGoodReview && <div>⭐⭐⭐⭐</div>}
    </div>
  )
}
```

---

### 6. **Conditional Rendering with Components**

**Key Points**:

- Combine map and conditional logic for dynamic components.
- Pass props and use conditions inside child components.

**Code Example**:

```jsx
function StarRating({ rating }) {
  return (
    <div>
      {[...Array(5)].map((_, i) => (
        <span
          key={i}
          style={{ color: i < rating ? 'gold' : 'lightgray' }}>
          ★
        </span>
      ))}
    </div>
  )
}
```

This collection provides a solid foundation in JSX and React concepts, complete with practical code examples. Let me know if you need further elaboration!

## Components

### 1. **Root Component**

To set up a root in React:

1. Import `React` and `ReactDOM`.
2. Select the root element from your `HTML` document.
3. Use `ReactDOM.createRoot` and render the main component, typically `<App />`.

**Code Example:**

```jsx
import React from 'react'
import ReactDOM from 'react-dom/client'
import './index.css'
import App from './App'

const rootElement = document.getElementById('root')

ReactDOM.createRoot(rootElement).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
)
```

---

### 2. **Creating Components**

**Component Breakdown**

**Scenario:** Split an `App` component into sub-components (`Header` and `Form`).

1. Create individual files for each component.
2. Import and use these components within the `App` component.

**Code Example:**

- `App.jsx`:

  ```jsx
  import React from 'react'
  import Header from './Header'
  import Form from './Form'

  export default function App() {
    return (
      <div className='container'>
        <Header />
        <Form />
      </div>
    )
  }
  ```

- `Header.jsx`:

  ```jsx
  import React from 'react'

  export default function Header() {
    return (
      <header>
        <h1>Welcome</h1>
      </header>
    )
  }
  ```

- `Form.jsx`:

  ```jsx
  import React from 'react'

  export default function Form() {
    return (
      <form>
        <input
          type='email'
          placeholder='Email'
        />
        <input
          type='password'
          placeholder='Password'
        />
        <button type='submit'>Submit</button>
      </form>
    )
  }
  ```

---

### 3. **Purity and Side Effects**

A React component should be pure, meaning its output is predictable and depends solely on its input props.

**Example Issue:** A `Discussion` component incrementing a global counter results in unintended side effects due to React's rendering behavior.

**Solution:** Use props to pass data predictably.

```jsx
export default function Discussions() {
  return (
    <ul>
      <Discussion count={1} />
      <Discussion count={2} />
    </ul>
  )
}

function Discussion({ count }) {
  return <li>Discussion {count}</li>
}
```

---

### 4. **Lists and Keys**

React requires unique keys for lists to optimize rendering. Use `filter` and `map` for dynamically creating components.

**Code Example:**

```jsx
const projects = [
  { id: 1, name: 'Project A', isPinned: true },
  { id: 2, name: 'Project B', isPinned: false },
  { id: 3, name: 'Project C', isPinned: true },
]

export default function App() {
  return (
    <ul>
      {projects
        .filter(project => project.isPinned)
        .map(project => (
          <li key={project.id}>{project.name}</li>
        ))}
    </ul>
  )
}
```

---

### 5. **Fragments**

Fragments allow returning multiple elements without adding extra nodes to the DOM.

**Example:** Conditional rendering based on authentication.

```jsx
function Navbar({ isAuthUser }) {
  return (
    <div className='navbar-links'>
      {isAuthUser ? (
        <>
          <a href='/dashboard'>Dashboard</a>
          <a href='/logout'>Sign Out</a>
        </>
      ) : (
        <a href='/login'>Log In</a>
      )}
    </div>
  )
}
```

---

### **Key Takeaways:**

- Use `React.StrictMode` during development for identifying potential issues.
- Break down components into smaller, reusable units.
- Ensure components are pure and predictable.
- Use `filter`, `map`, and keys effectively when working with lists.
- Employ fragments to maintain clean and minimal DOM structure.

Let me know if you'd like to explore any of these sections further!

---

## Props

Here is a detailed summary of the React concepts and their solutions included in the provided notes:

---

### 1. **Props Basics**

- **Concept:** Props are a way to pass dynamic data to React components.
- **Example:**
  ```jsx
  <Avatar
    imageSrc='https://example.com/image.jpg'
    name='Tom Cook'
    profileText='See profile'
  />
  ```
  - Props (`imageSrc`, `name`, `profileText`) are passed as attributes to the `Avatar` component.
  - Inside the component, these props are accessed via the `props` object:
    ```jsx
    function Avatar(props) {
      return (
        <img
          src={props.imageSrc}
          alt={props.name}
        />
      )
    }
    ```

---

### 2. **Passing Props**

- **Task:** Customize a `FormInput` component dynamically.
- **Example:**
  ```jsx
  <FormInput
    id='email'
    type='email'
    label='Email'
    placeholder='you@example.com'
    message="We'll only use this for spam."
  />
  ```
- Inside the component:
  ```jsx
  function FormInput({ id, type, label, placeholder, message }) {
    return (
      <label htmlFor={id}>{label}</label>
      <input id={id} type={type} placeholder={placeholder} />
      <p>{message}</p>
    );
  }
  ```

---

### 3. **Props in Lists**

- **Task:** Use props and `map` to render a list dynamically.
- **Example:**
  ```jsx
  function PhotoList({ files }) {
    return (
      <ul>
        {files.map((file, index) => (
          <PhotoListItem
            key={index}
            file={file}
          />
        ))}
      </ul>
    )
  }
  ```
  - Pass each file object as a prop (`file`) to `PhotoListItem`.

---

### 4. **Destructuring Props**

- **Concept:** Simplify prop usage using object destructuring.
- **Example:**
  ```jsx
  function Card({ username, avatar, date, message }) {
    return (
      <div>
        <img
          src={avatar}
          alt={username}
        />
        <p>{username}</p>
        <p>{date}</p>
        <p>{message}</p>
      </div>
    )
  }
  ```
- Props are directly destructured in the function parameters.

---

### 5. **Children Props**

- **Concept:** Pass JSX as children for better composition.
- **Example:**
  ```jsx
  function BoxButton({ children }) {
    return <button className='box-button'>{children}</button>
  }
  ```
  Usage:
  ```jsx
  <BoxButton>
    <span>Click Me!</span>
  </BoxButton>
  ```

---

### **Best Practices**

1. **Naming Conventions:** Use camelCase for prop names to maintain consistency.
2. **Default Values:** Provide default values for props where applicable.
3. **Validation:** Use tools like PropTypes for type-checking props in large applications.
4. **Key Prop in Lists:** Always provide a `key` when rendering lists with `map`.

---

## State

### 1. **useState Hook**

The `useState` hook is fundamental in React for managing component-level state. It allows you to declare state variables and provides a function to update the state while ensuring React re-renders the component when the state changes.

#### Example: Tab Component

**Problem:** Toggle the appearance of tabs dynamically when clicked.

**Solution:**

1. Declare a `useState` variable to track the current tab.
2. Update the tab state using the setter function provided by `useState`.

```jsx
const [currentTab, setCurrentTab] = useState('Company')

return (
  <div>
    {tabs.map(tab => (
      <button
        key={tab}
        onClick={() => setCurrentTab(tab)}
        style={{
          backgroundColor: currentTab === tab ? 'blue' : 'white',
          color: currentTab === tab ? 'white' : 'black',
        }}>
        {tab}
      </button>
    ))}
  </div>
)
```

---

### 2. **Multiple State Variables**

For forms or components requiring multiple pieces of state, `useState` can be called multiple times.

#### Example: Personal Info Form

**Problem:** Manage `firstName`, `lastName`, and `timezone` inputs and disable the save button if any value is missing.

**Solution:**

1. Create separate state variables.
2. Update state with `onChange` handlers.

```jsx
const [firstName, setFirstName] = useState('')
const [lastName, setLastName] = useState('')
const [timezone, setTimezone] = useState('Eastern Time')

const isDisabled = !firstName || !lastName || !timezone

return (
  <form>
    <input
      value={firstName}
      onChange={e => setFirstName(e.target.value)}
      placeholder='First Name'
    />
    <input
      value={lastName}
      onChange={e => setLastName(e.target.value)}
      placeholder='Last Name'
    />
    <select
      value={timezone}
      onChange={e => setTimezone(e.target.value)}>
      <option value='Eastern Time'>Eastern Time</option>
      <option value='Pacific Time'>Pacific Time</option>
    </select>
    <button disabled={isDisabled}>Save</button>
  </form>
)
```

---

## 3. **Arrays in State**

Arrays in state can be manipulated using methods like `filter` and `map`. React ensures the UI updates when the state array changes.

#### Example: Order Summary

**Problem:** Remove products from an order summary when the trash button is clicked.

**Solution:**

1. Use `filter` to create a new array excluding the deleted product.
2. Update the state with the filtered array.

```jsx
const [products, setProducts] = useState(cartProducts)

const removeProduct = id => {
  setProducts(products.filter(product => product.id !== id))
}

return (
  <ul>
    {products.map(product => (
      <li key={product.id}>
        {product.name} - {product.price}
        <button onClick={() => removeProduct(product.id)}>Delete</button>
      </li>
    ))}
  </ul>
)
```

---

## 4. **Objects in State**

When managing state with objects, ensure immutability using the spread operator.

### Example: Update Billing Address

**Problem:** Update the country and postal code without affecting other properties in the object.

**Solution:**

1. Use the spread operator to copy the existing object and update only the changed fields.

```jsx
const [card, setCard] = useState({
  number: '1234',
  expiration: '12/24',
  country: 'USA',
  postalCode: '12345',
})

const updateBilling = e => {
  setCard({
    ...card,
    [e.target.name]: e.target.value,
  })
}

return (
  <div>
    <select
      name='country'
      onChange={updateBilling}
      value={card.country}>
      <option value='USA'>USA</option>
      <option value='Canada'>Canada</option>
    </select>
    <input
      name='postalCode'
      onChange={updateBilling}
      value={card.postalCode}
    />
  </div>
)
```

---

## 5. **Sharing State**

Sharing state requires "lifting state up" to a common parent and passing it down via props.

### Example: FAQ Accordion

**Problem:** Allow only one accordion to be open at a time.

**Solution:**

1. Move `isOpen` state to the parent component.
2. Pass the state and setter function to child components as props.

```jsx
const [selectedIndex, setSelectedIndex] = useState(null)

return (
  <dl>
    {faqs.map((faq, index) => (
      <Accordion
        key={index}
        isOpen={index === selectedIndex}
        onSelect={() => setSelectedIndex(index)}
        faq={faq}
      />
    ))}
  </dl>
)

function Accordion({ isOpen, onSelect, faq }) {
  return (
    <div>
      <button onClick={onSelect}>{faq.question}</button>
      {isOpen && <p>{faq.answer}</p>}
    </div>
  )
}
```

---

These examples provide a detailed roadmap for managing various React state scenarios, ensuring seamless and dynamic user experiences.
