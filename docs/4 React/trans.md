1 create post page

Now that we can create new users via the signup page, let's see how to create new posts. We don't have a Create Page just yet, so we can go ahead and create that by adding a folder to app called Create. Within that, add a page.tsx file. We'll export a default component named CreatePostsPage. We're going to add a very similar user interface to our signup page. We'll have a main element which wraps a form. The form will have an h1 with the text "Create Draft", because when a user first creates a post, it's going to be unpublished and known as a draft post. Users will have the option to publish it or delete it later on. There will be two inputs and a text area within the form. We'll have an input with the name title for the title of the post, a placeholder text of "Title", and a type of text. To map it to a given user, we'll have an email input with a placeholder of "Author Email Address", and this will be of type email. Finally, we'll have a text area. This is where users can type in Markdown, which will be the content of the post. It will have a name attribute of content, 50 columns, and 8 rows, with a placeholder text of "Content". We'll also have a Submit button with a type of submit and text "Create Post", and a link to go back to the homepage with the text "Cancel".

So far, this looks pretty good. I'll create a create-post.module.css file within the Create folder. Here, I'm going to add a class called back, where margin-left is set to 1rem. I'll import styles from that file and then add the class to the link with className={styles.back}.

Since we're currently in a page that is a server component, and we need to perform an action to create a new resource (i.e., to create a post), we can use a server action. With this form, we'll make an async function named submitAction, where we'll get our form data as parameters. Make sure you provide useServer at the very top; not doing so will result in an error. Here, we want to get from formData the title and convert it to a string, and put it in a title variable. We'll do the same for email as well as content. We'll add another conditional to make sure that we have each of these as truthy values (i.e., non-empty string values). If so, we can await Prisma. Make sure to import that from the lib folder, and use the post property to interact with the post table. We want to create a post, and to do so, we need to add data to the data property. A post consists of a title and content (which is optional), as well as the author (which is optional). So, technically, we could change our conditional to just say "if we have a title". For the data, we need to set the title, email, and content. However, only content and title are going to be directly on the data object. Again, since author is a relationship, we need to select Author and use the Connect property here to connect an author with this post that we're creating, via their email. We can use the email since it's a unique field. After creating the post, we want to redirect. We'll import the redirect function from next/navigation and redirect to the drafts page, since that's what's going to be created.

We're not using submitAction just yet; we need to connect it to the form via the action prop. Now we can go ahead and create a post. We need to check our users to make sure that we're connecting with the email of a user that actually exists. If you don't have one, make sure to create one. Within the text area, we can write in Markdown. We'll see how to render that Markdown within our application. You can use Markdown syntax if you're familiar with it, to write titles and any other built-in Markdown elements. You can bold text, italicize stuff, make links, whatever. So, let's create a post. When we do that, however, we get a 404 error. This is because we haven't created the drafts page. Let's go ahead and do that quickly. Once again, we'll just make a component named DraftsPage and we'll return a div with the text "Drafts". We were redirected successfully. If we check out the studio, we can see that the post was created with the content we provided. Its published state is set to false. And we do have a connected user. If we look at the author column here, we see that when we click on it, we see the user that it has a relationship with according to the author's email.

2 drafts page

Now, let's move on to the drafts page to display all the unpublished posts we have in our app. It's going to look a lot like the homepage where we'll be displaying drafts. We'll start by creating the page in the Drafts folder. We'll return a main element with an h1 of "Drafts". To get our drafts data, we can use a similar approach as the homepage. We'll use the post model and the findMany function, but this time, we'll filter for where published is false. So, by making the DraftsPage an async component, we can modify our query to filter for published being false. Here, instead of getting posts, we'll be getting drafts that we can map over. We'll use drafts.map, and for each draft (or post), we'll return a div with a key set to post.id. Within the div, we'll use the Post component, so make sure to import that from App/components/post. We'll pass down all the post data on a post prop.

Next, let's add some dedicated styles for our drafts page. We'll create a drafts.module.css file in the Drafts folder. We'll start with a draft class where the background of each card will be white. We'll also add a bit of transition. When we hover over it, there will be a transition on the box-shadow property over 0.1 seconds, easing in. We'll add padding on the sides of 1rem and on the top and bottom of 2rem. Within the draft class, we'll have an h2 where we'll set the margin-top to 0 to remove any margin. When we hover over the draft card, the draft class will set the box-shadow to 1px 1px 3px #AAA. Finally, if we have two sibling draft elements, we'll apply a margin-top of 2rem to separate them.

Back in the DraftsPage, we'll import styles from the drafts.module.css file. Here, we'll apply the draft class to the div surrounding the Post component. So, we'll set className to styles.draft.

Taking a look at our page, we can see that the drafts are successfully displayed when they are not published, while our published posts remain on the homepage. And now, we're ready to move on to displaying individual posts as well as their Markdown content on a dynamic route.

3 dynamic page routes

In Next.js, creating dynamic routes is easy. You can do this by adding a folder to the app folder with a set of brackets around it. For example, in a blog, you could have a route like /blog/[slug]. Using this pattern, you can receive the value of the slug within the component on every page. The params, which is the word specified in the brackets in the folder structure, will be accessible on the params object. The value of the slug will be available as params.slug. The purpose of this is to fetch data based on the value passed when a user navigates to that route.

In our case, we have a route path starting with /posts/[postId]. This dynamic segment in the route path is where we'll receive the postId. To structure this in our app folder, we'll create a posts folder. Within it, we'll add another folder with brackets around it. We can name this folder postId to represent the dynamic segment. Inside this folder, we'll create our page component, let's call it postPage, which will return a simple div.

However, it's important to note that we want to display real content only for valid posts, as we'll be fetching data based on it. If the value passed doesn't match a valid postId, we want to show the "not found" page.

To achieve this, we'll first need to get access to the params. You saw from the documentation that we can access the params using params.postID. To fix the type error, we'll need to define a props interface that includes a params property with postId as a property of type string. We'll use this postId to fetch an individual post using Prisma's findUnique method. We'll use the where clause to filter for the id that matches the postId param.

To handle cases where the post doesn't exist, we'll use the notFound function from next/router to show the "not found" page.

The next step is to display the post content, including its title, author, and Markdown content. We'll install the markdown-to-jsx package using npm i markdown-to-jsx. This package will help us convert Markdown content into JSX for rendering.

We'll create a new component called PostDetails where we'll render the post's content. We'll return a main element containing the title, author, and the Markdown content. We'll use the markdown-to-jsx component to render the Markdown content. We'll conditionally display the title based on whether the post is published or not. Additionally, we'll add buttons to either publish or delete the post.

For styling, we'll create a PostDetails.module.css file and add classes for styling the buttons and section.

Once we have the PostDetails component ready, we'll import it into our PostPage component and spread the post properties to make them accessible. We'll use the spread syntax for this.

Now, we'll be able to display the post's title, author, and Markdown content on the dynamic route. The buttons for publishing and deleting the post are also in place. In the next steps, we'll work on making these buttons functional to publish and delete posts.

4 dynamic route handles

Next, we want to either publish or delete our posts based on their post ID. This is essential to identify the specific post we want to publish or delete. To achieve this, we either need to update the post, performing a PUT request to change its published status from false to true, or delete the post entirely using a DELETE request. Although making these requests differs, the concept remains consistent: creating dynamic routes not only for user-facing pages but also for route handlers.

Since we're dealing with posts, we can navigate to the api folder and create a dynamic segment for the route handlers. Inside the posts folder, we'll create another subfolder enclosed in brackets, naming it postID. This folder will contain a route.ts file instead of a .tsx file as used in page routes.

Let's start by implementing the functionality to publish posts. We'll export an async function, naming it in all caps to indicate it handles a PUT request to publish a post. This function will be responsible for making a PUT request to the /api/posts endpoint, with the specific post ID included in the request URL.

To access the post ID parameter sent with the request, we can utilize the context object. This object contains a params property, similar to dynamic pages, where the dynamic value specified in the route is accessed. In this case, we name it postID. We'll need to convert it to a number and store it in a variable for further use.

Using the prisma library, we'll perform an update operation on the post. We'll use the Update method, providing the necessary filter and data. We'll set the published field to true to indicate the post is published. Upon completion, we'll return a success response with a status code of 200.

Now, to interact with this endpoint from the front-end, we'll modify the PostDetails component. We'll add an onClick event to the publish button that triggers a function called publishPost. This function will make a PUT request to the API, targeting the specific post ID, and then navigate to the homepage.

To handle the PUT request, we'll make use of the Fetch API and use template strings to construct the request URL. Once we've published a post, we'll refresh the current page to ensure the latest data is displayed. For proper functioning, the PostDetails component should be a client component, so we'll add useClient at the top to avoid event handler-related issues.

Next, we'll address the delete functionality. Similar to publishing, we'll create an async function named Delete in the route handler's route.ts file. This function will handle DELETE requests to delete a post based on its post ID. We'll again use the params object to access the post ID, convert it to a number, and perform a deletion operation using the prisma library's Delete method.

In the PostDetails component, we'll add an onClick event to the delete button, triggering a function called deletePost. This function will make a DELETE request to the API, delete the specified post, and then refresh the current page.

After implementing these functionalities, you'll have full CRUD (Create, Read, Update, Delete) functionality for your posts. You can create new posts, read and display them on dynamic routes, update their published status, and delete them as needed. This comprehensive functionality ensures a complete user experience for managing posts in your application.
