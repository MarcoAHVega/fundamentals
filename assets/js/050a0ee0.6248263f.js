"use strict";(self.webpackChunkfundamentals=self.webpackChunkfundamentals||[]).push([[7167],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var o=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var i=o.createContext({}),c=function(e){var t=o.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=c(e.components);return o.createElement(i.Provider,{value:t},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,i=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(n),d=r,m=u["".concat(i,".").concat(d)]||u[d]||h[d]||a;return n?o.createElement(m,l(l({ref:t},p),{},{components:n})):o.createElement(m,l({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,l=new Array(a);l[0]=d;var s={};for(var i in t)hasOwnProperty.call(t,i)&&(s[i]=t[i]);s.originalType=e,s[u]="string"==typeof e?e:r,l[1]=s;for(var c=2;c<a;c++)l[c]=n[c];return o.createElement.apply(null,l)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},5574:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var o=n(7462),r=(n(7294),n(3905));const a={sidebar_position:16},l="Component Level Rendering",s={unversionedId:"5 Next.js 13/16 Component Level Rendering",id:"5 Next.js 13/16 Component Level Rendering",title:"Component Level Rendering",description:"what exactly a client and a server really is.",source:"@site/docs/5 Next.js 13/16 Component Level Rendering.md",sourceDirName:"5 Next.js 13",slug:"/5 Next.js 13/16 Component Level Rendering",permalink:"/fundamentals/5 Next.js 13/16 Component Level Rendering",draft:!1,tags:[],version:"current",sidebarPosition:16,frontMatter:{sidebar_position:16},sidebar:"tutorialSidebar",previous:{title:"Learning Rendering and Data Fetching",permalink:"/fundamentals/5 Next.js 13/15 Learning Rendering and Data Fetching"},next:{title:"Data Fetching Approaches",permalink:"/fundamentals/5 Next.js 13/17 Data Fetching Approaches"}},i={},c=[{value:"what exactly a client and a server really is.",id:"what-exactly-a-client-and-a-server-really-is",level:3},{value:"client component",id:"client-component",level:3},{value:"server components",id:"server-components",level:3},{value:"why server components",id:"why-server-components",level:3},{value:"To use a client component",id:"to-use-a-client-component",level:3},{value:"So how do we make a choice on when to use the client versus the server component",id:"so-how-do-we-make-a-choice-on-when-to-use-the-client-versus-the-server-component",level:3},{value:"when are Server components use?",id:"when-are-server-components-use",level:3}],p={toc:c},u="wrapper";function h(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,o.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"component-level-rendering"},"Component Level Rendering"),(0,r.kt)("h3",{id:"what-exactly-a-client-and-a-server-really-is"},"what exactly a client and a server really is."),(0,r.kt)("p",null,"With the latest Next.js 13, you can choose a rendering environment at the component level, it provides support for both client and server components."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The client refers to the browser on a user's device that sends a request to the server for your application code.")),(0,r.kt)("p",null,"It then returns the response from the server into an interface that the user can interact with."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The server, on the other hand, refers to the computer in a data center that stores your application code. It receives requests from the client, does some computation, and sends back an appropriate response. All right,")),(0,r.kt)("h3",{id:"client-component"},"client component"),(0,r.kt)("p",null,"In Next.js, client components are components that are rendered on the client."),(0,r.kt)("p",null,"They can also be pre-rendered on the server and hydrated on the client."),(0,r.kt)("h3",{id:"server-components"},"server components"),(0,r.kt)("p",null,"With Next.js 13, all components inside the app folder that we've seen so far are server components by default."),(0,r.kt)("p",null,"You can choose to use a client component instead by specifying it explicitly."),(0,r.kt)("h3",{id:"why-server-components"},"why server components"),(0,r.kt)("p",null,"These components allow you to render components on the server and reduce the amount of JavaScript sent to the client. Isn't that cool?"),(0,r.kt)("p",null,"This is a new concept and taps into an entirely performant way of rendering React components."),(0,r.kt)("p",null,"Let's take a look at this component tree here, for example."),(0,r.kt)("p",null,"The pink components here represents server components, and the blue components are the client components."),(0,r.kt)("p",null,"You can see here that you can interleave server and client components in your application."),(0,r.kt)("p",null,"You could do it as you like across the component tree or on a per\u2011component basis."),(0,r.kt)("p",null,"React will seamlessly merge the work of both environments without any additional work from your end."),(0,r.kt)("h3",{id:"to-use-a-client-component"},"To use a client component"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"So, as we saw earlier, all components inside the Next.js app folder are server components by default.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"To use a client component, you would create a file inside the app folder and add the ",(0,r.kt)("inlineCode",{parentName:"p"},"'use client'")," directive at the top of the file.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"This should be before any imports are added."))),(0,r.kt)("p",null,"You only need to mark components as use client when they use client hooks, such as useState or useEffect."),(0,r.kt)("p",null,"In our case, this Counter component uses a state hook and hence needs to be marked as a client component."),(0,r.kt)("p",null,"It's best to leave components that do not depend on client hooks without the client directive so that they can automatically be rendered as a server component."),(0,r.kt)("p",null,"This helps ensure the smallest amount of client\u2011side JavaScript."),(0,r.kt)("h3",{id:"so-how-do-we-make-a-choice-on-when-to-use-the-client-versus-the-server-component"},"So how do we make a choice on when to use the client versus the server component"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The rule of thumb is to ",(0,r.kt)("inlineCode",{parentName:"li"},"use a client component if you use any of the React hooks"),", such as useState, useEffect, useReducer, and so on.")),(0,r.kt)("p",null,"This means there are going to be changes within the component that needs to be rendered on the client."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"If there is any sort of interactivity with the component"),", such as event listeners you have on button click and so on, you would use a client component."),(0,r.kt)("p",null,"Also, ",(0,r.kt)("inlineCode",{parentName:"p"},"if there are custom hooks that depend on state and effects"),", they have to be client components too."),(0,r.kt)("p",null,"In all other cases, you'll use a server component by default."),(0,r.kt)("h3",{id:"when-are-server-components-use"},"when are Server components use?"),(0,r.kt)("p",null,"Server components are used while ",(0,r.kt)("inlineCode",{parentName:"p"},"fetching data"),","),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"storing sensitive information")," on the server, such as tokens, API keys, and so on."),(0,r.kt)("p",null,"And ",(0,r.kt)("inlineCode",{parentName:"p"},"if the component must access back\u2011end resources directly"),", then it would be a server component too."),(0,r.kt)("p",null,"Make sure to use a server component ",(0,r.kt)("inlineCode",{parentName:"p"},"to also keep large dependencies on the server"),"."),(0,r.kt)("p",null,"(So far within our Globomantics app, we did not really create components with interactivity or use any client hooks, so all our components inside the app folder or server components by default."),(0,r.kt)("p",null,"If we ever want to change them, we'll include the use client directive at the very top of a component's file.)"))}h.isMDXComponent=!0}}]);