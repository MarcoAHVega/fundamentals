"use strict";(self.webpackChunkfundamentals=self.webpackChunkfundamentals||[]).push([[2631],{3905:(e,t,n)=>{n.d(t,{Zo:()=>l,kt:()=>f});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var h=o.createContext({}),c=function(e){var t=o.useContext(h),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},l=function(e){var t=c(e.components);return o.createElement(h.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},p=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,h=e.parentName,l=r(e,["components","mdxType","originalType","parentName"]),u=c(n),p=a,f=u["".concat(h,".").concat(p)]||u[p]||d[p]||i;return n?o.createElement(f,s(s({ref:t},l),{},{components:n})):o.createElement(f,s({ref:t},l))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,s=new Array(i);s[0]=p;var r={};for(var h in t)hasOwnProperty.call(t,h)&&(r[h]=t[h]);r.originalType=e,r[u]="string"==typeof e?e:a,s[1]=r;for(var c=2;c<i;c++)s[c]=n[c];return o.createElement.apply(null,s)}return o.createElement.apply(null,n)}p.displayName="MDXCreateElement"},2629:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>r,toc:()=>c});var o=n(7462),a=(n(7294),n(3905));const i={sidebar_position:3},s="Asynchronous JavaScript",r={unversionedId:"3 JavaScript/3 Asynchronous JavaScript",id:"3 JavaScript/3 Asynchronous JavaScript",title:"Asynchronous JavaScript",description:"Intro",source:"@site/docs/3 JavaScript/3 Asynchronous JavaScript.md",sourceDirName:"3 JavaScript",slug:"/3 JavaScript/3 Asynchronous JavaScript",permalink:"/fundamentals/3 JavaScript/3 Asynchronous JavaScript",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Advanced JavaScript",permalink:"/fundamentals/3 JavaScript/2 Advanced JavaScript"},next:{title:"REACT",permalink:"/fundamentals/category/react"}},h={},c=[],l={toc:c},u="wrapper";function d(e){let{components:t,...n}=e;return(0,a.kt)(u,(0,o.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"asynchronous-javascript"},"Asynchronous JavaScript"),(0,a.kt)("p",null,"Intro"),(0,a.kt)("p",null,"hey everyone my name is vishwas and welcome to this crash course on asynchronous javascript\nin this crash course we will understand some of the topics related to async javascript\nnow if you've been watching my other crash courses this one is going to be a bit different\nif you're sort of new to the channel i would like to point out that i have a paid course\non preparing for a front-end interview this course covers a number of topics\nwith javascript being one of them i've also covered in detail the concepts\nrelating to async javascript in very simple terms i feel every javascript developer must\nhave a good understanding of the async concepts so i've decided to include the entire async javascript lectures from\nthe paid course into this video if you feel the content is helpful\nplease do consider purchasing the course and i will leave a link to this in the description down below\nwith this intro i'll let you get started with asynchronous javascript"),(0,a.kt)("p",null,"What, Why and How?"),(0,a.kt)("p",null,"all right we are now at the last important topic when it comes to javascript interviews\nand that is asynchronous javascript we need to understand the basics of\nasync programming and why async javascript is important\nunder this topic we have a few concepts to cover from an interview point of view\nwe have timeouts and intervals callbacks promises async await and the all\nimportant event loop if you are a junior dev applying for an interview\na surface knowledge of these topics will suffice however if you are applying for a more\nsenior role you're expected to have a deeper understanding of all these topics\nso here is how we are going to approach this part in this lecture we are going to\nunderstand the what and why of async javascript in the upcoming videos we will see the\nhow of async javascript by understanding and solving exercise problems on\ntimeouts callbacks promises and async await\nwe will wind up async javascript by understanding how all of them behave with respect to the event loop\nwith that in mind let's begin now the first point to understand about\njavascript is that in its most basic form javascript is a synchronous blocking\nsingle threaded language and the three points mentioned here are really important\nlet's understand what they mean the first point is that javascript is\nsynchronous so if we have two functions which log\nmessages to the console code executes top down with only one\nline executing at any given time so if we have function a and function b\nand we call both the function javascript will always log a and then\nb the second point is that javascript is blocking which is because of its\nsynchronous nature no matter how long a previous process takes the subsequent process won't kick\noff until the former is completed so if function a has to execute an\nintensive chunk of code javascript has to finish that task without moving on to\nfunction b even if that code takes 10 seconds or 1 minute\nyou might have seen this happen in the browser when a web app runs in a browser and it\nexecutes an intensive chunk of code without returning control to the browser the browser\ncan appear to be frozen this is called blocking the browser is\nblocked from continuing to handle user input and perform other tasks until the\nweb app returns control of the processor the last point is that javascript is\nsingle threaded a thread is simply a process that your javascript program can use to run a task\nand each thread can only do one task at a time unlike a few other languages which\nsupport multi-threading and can thus run multiple tasks in parallel javascript has just the one thread\ncalled the main thread for executing any code this brings us back to the point that in\nits most basic form javascript is a synchronous blocking single threaded\nlanguage but as you might have already guessed\nthis model of javascript creates a huge problem what if we have a task to retrieve data\nfrom the database and then run some code on that data that is retrieved\nwe have to wait on the first line for the data to be fetched and when the data finally comes back we can resume with\nour normal execution but that could take like one second or\neven more and during that time we can't run any further code\nin javascript if it simply proceeds to the next line without waiting we have an\nerror because data is not what we expect it to be so\nwe need a way to have asynchronous behavior with javascript\nnow the question is how do we cater to asynchronous programming in javascript\nwell as it turns out just javascript is not enough to achieve that\nwe need new pieces which are outside of javascript to help us write asynchronous code which is where web browsers come\ninto play web browsers define functions and apis\nthat allow us to register functions that should not be executed synchronously and\nshould instead be invoked asynchronously when some kind of an event occurs\nfor example that could be the passage of time the user's interaction with the mouse or the\narrival of data over the network this means that you can let your code do\nseveral things at the same time without stopping or blocking your main thread\nalright i hope you now have a fair understanding of what why and how of\nasync javascript in the next lecture let's begin with the traditional methods javascript has\navailable for running code asynchronously"),(0,a.kt)("p",null,"Timeouts and Intervals"),(0,a.kt)("p",null,"in this lecture let's look at the traditional methods javascript has available for running code asynchronously after a set time period elapsed or at regular intervals of time\nin other words let's look at the set timeout function and the set interval function\nlet's begin with set timeout the set timeout function executes a\nparticular block of code once after a specified time has elapsed\nlet's understand the parameters it accepts the first parameter is a function to run\nor a reference to a function defined elsewhere the second parameter is a number\nrepresenting the duration in milliseconds to wait before executing\nthe code after the second parameter you can pass in zero or more values that represent\nany parameters you want to pass to the function when it is run\nsuppose we have a function greet which logs hello to the console we can pass that function into set\ntimeout with a duration of two seconds the text hello will be logged to the\nconsole after two seconds if the grid function were to accept a\nparameter like we see in the next example we can pass the parameter value as the\nthird argument to set timeout and after two seconds hello vishwas would be\nlogged to the console once a set timeout has been called\nsometimes you might want to cancel it to clear a timeout you can use the clear\ntimeout method passing in the identifier returned by settimeout as a parameter\nso in the code snippet on line 5 you can see that we assigned the return value\nfrom set timeout to a constant called timeout id on line 6 we pass that id into the clear\ntimeout method which will basically ensure our grid function will not run\nafter the two second duration so nothing is logged to the console as the grid function never executes\na more practical scenario is clearing timeouts when the component is unmounting to free up the resources and\nalso prevent the code from incorrectly executing on an unmounted component\nso that is about set timeout it runs code once after a set period of time\nif you however want to repeatedly run the same code over and over again at regular intervals you can make use of\nthe set interval function the signature remains the same as the set timeout function\nfirst parameter is the code to execute second parameter is the duration in milliseconds and then zero or more\narguments for the passed in function in this sample code snippet the function\ngreet is called every two seconds which logs hello to the console every two seconds\nanother point to keep in mind is that intervals keep running a task forever so\nyou should clear the interval when appropriate you can do that using the clear interval\nfunction so capture the return value from set interval and pass it in as an argument\nto clear interval that is pretty much the basics of\ntimeouts and intervals now there are a few more points to highlight so let's go through them\nthe first point is that timers and intervals are not part of javascript itself\nthey are implemented by the browser and set timeout and set interval are basically names given to that\nfunctionality in javascript let me repeat that timers and intervals are not features of\njavascript however javascript lets us use those features which are implemented in the\nbrowser and of course node the second point is about the duration\nparameter the duration specified is the minimum delay and not guaranteed delay\nfor example if we call set timeout with two seconds two seconds is the minimum time after\nwhich the passed in function will execute it could in fact take 5 seconds\njavascript will only run the function when two seconds have elapsed and the\ncall stack is free if not the function has to wait before it is executed\nso if i type in set timeout with 0 milliseconds as the duration it doesn't imply that the function will\nrun immediately it is the minimum duration after which the function will run\nnow if you're confused with this point you don't have to worry we're going to understand this in detail when we talk\nabout event loop a few lectures down the line the third and final point is about\nrecursive set timeout versus set interval it is possible to achieve the same\neffect as set interval with a recursive set timeout\nso we have set interval with a duration of 100 milliseconds\nand we have the same functionality with recursive set timeout\nbasically the run function keeps calling itself every 100 milliseconds\nhowever there are two differences in these approaches the first one is that in case of\nrecursive set timeout the same 100 milliseconds is guaranteed between\nexecutions the code will log hello to the console wait 100 milliseconds before it runs\nagain irrespective of how long the code takes to run the interval will remain the same\nset interval on the other hand works differently in the sense that the duration interval includes the time\ntaken to execute the code you want to run so if the first time the code takes 40\nmilliseconds to run the interval is only 60 milliseconds if the second time the code takes 50\nmilliseconds to run the interval is only 50 milliseconds\ntypically it shouldn't affect your code too much but if your code can take\nlonger to run than the time interval itself it's always better to go with recursive\nset timeout rather than set interval this will keep the time intervals\nconstant between executions regardless of how long the code takes to execute\nand also you won't get any errors the second difference is that with\nrecursive set timeout you can actually calculate a different delay before running each iteration\nso recursive set timeout gives you the flexibility of running the same code over and over but with different\nintervals whereas set interval is always a fixed interval duration\nall right now that we have a good understanding of set timeout and set interval let's head into the next\nlecture where we discuss some really important exercise problems from an interview point of view"),(0,a.kt)("p",null,"Callbacks"),(0,a.kt)("p",null,"welcome back in this lecture we are going to learn\nabout callbacks in javascript let's begin by understanding an\nimportant point in javascript functions are first class\nobjects what that means is that just like an object a function can be passed as an\nargument to a function and a function can also be returned as values from\nother functions let's understand this with a simple example\ni have a function called greet which accepts a name parameter and logs to the console hello followed\nby name i then have another function called greet vishwas\nwhat is special here is that the function accepts another function as its argument\nwithin the function body we have a const declaration name equal to vishwas\nand we call the passed in function with name as its argument finally we invoke greet vishwas\npassing in the greed function so the control goes to greet vishwas\nwhich calls greet fn greet fn is nothing but the greet\nfunction we have defined here so execution goes to the greet function\nwith name equals vishwas and hello vishwas is logged to the console\nsegrete vishwas is a function which accepts another function as an argument\nand you might be pleasantly surprised to learn that any function that is passed as an\nargument to another function is called a callback function in javascript\nalso the function which accepts a function as an argument or returns a function is\ncalled a higher order function if i simply rename the function and its\nargument to convey what they stand for on line 5 we have higher order function\nwhich accepts a callback function and then on line 7 calls that callback\nfunction passing in the name constant so we now know what a callback function\nis you might be thinking is that it well yes\na function passed as an argument to another function is called a callback function\nbut what we need to understand is why do we need a callback function\nwe can answer that by categorizing callbacks into two synchronous callbacks and asynchronous\ncallbacks let's first talk about synchronous callbacks\na callback which is executed immediately is called a synchronous callback\nagreed callback function from earlier is an example because the function gets executed immediately when the control\ngoes inside the higher order function a more practical example is a callback\nfunction passed to methods like sort map or filter in these cases the callback function\ndefines the logic that the higher order function needs to apply so nothing too fancy when it comes to\nsynchronous callback let's now move on to asynchronous callback which will also bring our focus\nback on asynchronous javascript an asynchronous callback is a callback\nthat is often used to continue or resume code execution after an asynchronous\noperation has completed so in the async world callbacks are used to delay the\nexecution of a function until a particular time or event has occurred\nand this use case is really important because most of the applications that we\nbuild usually have some sort of data to be fetched we all know that data\nfetching takes time and we can only run the function we want to after the data has been fetched and not\nimmediately let's take a look at a few examples on async callbacks which you might already\nbe using without knowing that their callback functions the first example is that of settimeout\nwhich we recently learned here set timeout acts as the higher\norder function and greet is the callback function when thread of execution goes through\nline number five does the grid function execute immediately no\nit waits for two seconds and then executes the great callback function making it an async callback\nanother common usage is event handlers when javascript encounters line number 5\nit does not immediately run the callback function the function is only run when the user\nclicks on the button if you want a data fetching example with callbacks you can go back to jquery if\nyou've used it before dollar dot get and the first parameter is the url and the\nsecond parameter is the callback function which gets called only after\nthe data has been loaded so this is the role that callback\nfunctions play in async javascript they allow you to delay the execution of\na function callbacks are something you're going to heavily see in node.js\nhowever there is a problem with the callbacks pattern if you have multiple callback functions\nwhere each level depends on the result obtained from the previous level the nesting of functions becomes so deep\nthat the code becomes difficult to read and maintain in the code snippet here you can see\nthat each inner function depends on the result obtained from the outer function\nso once you go several levels deep like on line 5 the nesting starts to confuse you\nthe code is just not intuitive and only gets worse with more and more callback\nfunctions as the application grows to tackle this problem of callback hell\npromises were introduced in es6 which we will learn about in the next lecture\nbut let me summarize about callbacks from an interview point of view\ncallbacks are functions passed as arguments to other functions they can be synchronous if they execute\nimmediately or they can be asynchronous where they get executed after some time\nhas passed some event has occurred or some data has been fetched\ncallbacks were the go to pattern for asynchronously running code after fetching some data\nhowever as more and more requests had to be made based on the data obtained from\nthe previous requests developers started to encounter what is known as the callback hell\ncallback hell makes the code difficult to reason about an alternative and the recommended\napproach now is to use promises let's learn about that in the next lecture"),(0,a.kt)("p",null,"Promise"),(0,a.kt)("p",null,"all right in this lecture we are going to learn about promises in javascript\nhere is a useful piece of info in about eighty percent of the interviews i appeared for i was asked\nabout promises so if you're appearing for a senior dev position you can take it for granted\nthat you will be asked about this topic so make sure you have a thorough understanding about promises in\njavascript i want to begin by helping you understand promises with a simple\nanalogy once you understand the big picture in simple layman terms we will then move on\nto understanding promises in javascript consider a scenario where you and your\nroommate want to have dinner at home you want to prepare your special soup\nand at the same time you feel like having tacos from the food truck nearby\nso you ask your roommate hey can you go down to the food truck and\nget us some tacos your friend says sure and when he's about to leave\nyou tell him there is no point in me waiting till you're back to prepare the soup\nso i'll start with the soup now but when you reach the place can you promise that you'll text me so\nthat i can start setting up the dining table also let me know if something goes wrong\nif you can't find the food truck or if they're out of tacos for the night whatever might be the reason just let me\nknow that you cannot get the tacos and i'll start cooking some pasta instead\nyour friend says sure i promise i'll head out now and text you in some time\nnow you go about preparing your soup but the status on tacos\nwe can say that it is currently pending till you receive that message from your friend\nwhen you get back a text message saying that he is getting the tacos your desire to eat tacos has been\nfulfilled you can then proceed to set up the dining table\nif the text message says that he cannot bring back any tacos your desire to have\ntacos have been rejected and now you have to cook some pasta instead\nall right now let's pick the important bits from the scenario and relate it\nback to javascript and promises in the scenario your friend is like a promise in\njavascript while your friend is on his way to the food truck you know that it could take a\nwhile and you don't want to sit idle so you start preparing soup in the meantime\nthis part is an analogy to an asynchronous operation in javascript\nfetch tacos when your friend texts you with can get tacos or can't get tacos\nit answers your question on whether he's getting the tacos or not in javascript this is the promise return\nvalue if the return value is can get tacos\nthe promise is said to be fulfilled if the return value is cannot get tacos\nfor whatever might be the reason the promise is said to be rejected\nif the promise is fulfilled you can set up the dining table this is a success callback\nor in other words it is the callback function that gets executed when promise\nresolved successfully the promise is rejected you can cook some pasta and this is the\nfailure callback or in other words it is the callback function that gets executed when the\npromise failed to resolve and was rejected instead\nthat pretty much is a high level overview of what a promise is in javascript\nlet's read through the mdn definition of a promise a promise is a proxy for a value not\nnecessarily known when the promise is created it allows you to associate handlers with\nan asynchronous actions eventual success value or failure reason\nto understand this definition better let's break it down a promise is a proxy for a value\ngoing back to our example your friend made a promise that he will let you know\nwhether he can or cannot get tacos which is the promise value\nthe promise value is not necessarily known when the promise is created\nin our example you don't know which one of them is the value when your friend made his promise\nhe can get tacos or cannot get tacos you don't necessarily know that value\na promise allows you to associate handlers with an asynchronous actions\neventual success value or failure reason in our example\nbased on the promise value you could decide ahead of time what has to be done when the promise is\neventually fulfilled or rejected that is either setting up the table or\ncooking pasta hopefully the definition makes much more\nsense now technically let me tell you that a promise is simply an object in\njavascript and a promise is always in one of the\nthree states pending which is initial state that is neither fulfilled nor rejected\nwe have fulfilled meaning that the operation completed successfully and we have the rejected state meaning\nthat the operation failed all right you should now be having a\nfair understanding of what a promise is in javascript now for the next question\nwhy would you use a promise well for one and only one purpose\npromises help us deal with asynchronous code in a far more simpler way compared\nto call backs remember the callback help we spoke about in the previous lecture\nwell that can be avoided with promises and the code can be sort of read in a simple synchronous way\nyou'll see this in just a bit when we take a look at an example all right that is the what and why about\npromises next let's see how to work with promises in javascript\nif you go back to our example we have your friend as an analogy for a\npromise we have can get tacos or cannot get tacos which is the promised value that\nyour friend should inform you about if he can get tacos he's fulfilling his\npromise if he cannot get tacos he is rejecting his promise\nand we have the success callback and the failure callback that we need to attach\nto the result returned by the promise either set up the table or cook pasta\nnow these six points cover the necessary information about a promise\nso now we need to understand three things in code\nhow to create a promise which covers point number one how to fulfill or reject the promise\nwhich covers points two three and four and finally how to execute callback\nfunctions based on whether the promise is fulfilled or rejected which covers\npoints 5 and 6. let's go over them one by one starting\nwith how to create a promise we create an instance of a promise using\nthe new keyword with the promise constructor function the const promise is equal to new\npromise next question how to fulfill or reject the promise\nwell it turns out that the promise constructor function accepts one function as its argument\nlet's pass in an arrow function this arrow function automatically\nreceives two arguments resolve and reject\nhere resolve and reject are both functions resolve is a function which when called\nchanges the status of the promise from pending to fulfilled\nreject is a function which when called changes the status of the promise to reject it\nthis is very important to keep in mind you cannot directly mutate the status of\na promise you can call the result function to fulfill the promise or the reject\nfunction to reject the promise but both these functions are typically\ncalled after an async operation to keep things simple let's use a set\ntimeout we're going to assume that for your friend to go out and text you back it\ntakes five seconds so our code now changes to incorporate the set timeout\nif the food truck was found we will call resolve after five seconds\nthe food truck was not found we call reject after five seconds\nthis is pretty much how you fulfill or reject a promise\nthe final part is to understand how to execute callback functions based on the\nstatus change of the promise let's define two callback functions\non fulfillment is the function to be called if result is called after the\nasync operation on rejection is the function to be called if reject is called after the\nasync operation going back to our analogy if the food truck was found\nour promise is fulfilled in which case we want to set up the table to eat tacos\nif the food truck was not found and our promise is rejected we have to start cooking the pasta\ni've turned those actions into log statements on line 3 and line 8.\nideally there would be more code in your callback functions but we simply log into the console and\nit serves the purpose now i keep telling you that we are defining callback functions\nbut callback functions are functions that are passed in as arguments to other functions\nright well where are those other functions this is the point where the promise we\nhave created comes into picture when we create a new promise using the\npromis constructor function the promise object gives us access to two methods\nor functions if you want to call it that then and catch\nwe call those functions using promis dot then and promise dot catch as you can\nsee on lines 18 and 19. but here is the important bit\nif the status of the promise changes from pending to fulfilled by calling the resolve function\nthe function that is passed to then function will automatically get invoked\nand if the status of the promise changes from pending to rejected by calling the reject function\nthe function that is passed to catch function will automatically get invoked\nin our case we need to pass on fulfillment function to then and on rejection function to\ncatch since the two functions are passed in as arguments to other functions they are\ncallback functions hopefully that makes sense now\nour promise code works as expected but there is room for improvement\nwhat if we want to send out some data when resolving or rejecting a promise\nthat way inside our callback functions we can make use of the value to do something else\nwell it turns out that we can do that by passing an argument to resolve or reject\nfor the resolve function on line 6 we'll pass in a string which says bringing\ntacos and for reject on line 40 i'll pass in a string that says not bringing tacos food\ntruck not there but how do we access these strings in our call back functions\nwell the great thing about a promise is that it will automatically inject the\nargument passed to resolve as the argument to the on fulfillment callback\nand the argument passed to reject as the argument to the on rejection callback\nyou can see that i've included parameters to both these callbacks and simply log them to the console on line\nthree in line nine so we would now see the output bringing tacos set up the table to eat\ntacos from lines three and four when the promise is fulfilled or if there is an error and hence a\nrejection we would see cannot bring tacos start cooking pasta\nfrom lines 9 and 10. of course in a practical scenario your\nresult would be an object or an array or any data type that your async operation\nreturns and the error might be an object with different error codes and in your on\nrejection callback handler you might want to perform different actions based on the error status code\nbut this pretty much is the fundamentals of promises in javascript\nduring an interview begin by explaining what is a promise and you don't have to give the technical\ndefinition from mdn it is probably better to explain in your own words\ntalk about how promises are used for async operations in javascript give an analogy to a real-world scenario\nand connect it back to javascript talk about the three states that a promise can be in namely pending\nfulfilled and rejected talk about the function that is passed into the promise constructor function\ntalk about the resolve and reject functions and how they change the state of the promise from pending to fulfilled\nor pending to rejected finally talk about the on fulfillment and on rejection callback functions\nwhich let you decide what to run when a promise is either fulfilled or rejected\nif you're applying for a junior dev role for the most part this should give the interviewer a good impression about your\nknowledge of promises however there are a few more details for us to understand\nwe will do that in the next lecture which is part two of promises\nin the previous lecture we learned the fundamentals of promises in javascript\nwe learned how to create a promise how to change its state using the resolve and reject functions\nand also how to attach callbacks using then and catch functions on the promise\nobject in this lecture let's understand a few more points around the concept of\npromises which are useful during an interview let's start with the first point which\nis regarding then function at the moment we pass in the on\nfulfillment callback to then function and on rejection callback to catch\nfunction but you could if you want to pass on rejection as a second argument\nto then function the code works exactly as before\nhowever the usage of catch function is encouraged because of one main reason\nin the below two argument approach the on rejection callback handles errors\nfrom only the promise however if your callback function itself throws\nan error or an exception there is no code to handle that\nif you have a catch function though even if your on fulfillment callback throws an exception\nit is still caught and then you can handle that exception gracefully so do\nmake a note that then function can accept both success and error callbacks\nbut it's not preferred over using catch function let's move on to the second point for\nthis lecture which is about chaining promises at the moment a promise is returned by\nusing the new keyword followed by the promise constructor function but let me tell you that\nboth then and catch methods return promises this means\nthen and catch methods can be changed in javascript so the two lines on line 5 and 6 can be\nrewritten as promise dot then on fulfillment dot catch on rejection\nand this chaining can be done as many times as you want to which also solves the problem of call\nback health we encountered a few lectures back so the code with callbacks looked like\nthis the same code with promises looks like this\nas you can see the code becomes much more readable and maintainable in fact\nit seems as if the code is synchronous we begin by fetching the current user\nthen fetch the followers then fetch their interests then fetch their tags then fetch the description\nand then finally display the data so this is really important to keep in\nmind not only from an interview point of view but also for your day-to-day work\npromises can be chained the last point to discuss when it comes to promises for an interview is some of\nthe static methods available with a promise the first one is the promise.all static\nmethod many a times you may want to query multiple apis and perform some actions\nbut only after all the apis have finished loading for such scenarios you can use promise\ndot all here is a good example from mdndocs to help you better understand this method\nin the example we have here the first promise immediately results\nthe second isn't really a promise and the third results after 100 milliseconds\nyou can pass in all the three promises as an array to promise dot all\nand you see the output as an array containing the results of the individual promises\nhowever please do keep in mind even if one of the promises rejects\npromise.all will reject with that error message\nso this example can be summarized into the following points\nthe promise.all method takes an iterable of promises as an input and returns a\nsingle promise that results to an array of the results of the input promises\nthe return promise will resolve when all of the input's promises have been resolved or if the input iterable\ncontains no promises however it rejects immediately if any of\nthe input promises reject or the non promises through an error and will reject with the first rejection message\nor error that is about promise promise.all\na slight variation of promise.all is promise.all settled which waits for all\ninput promises to complete regardless of whether or not one of them is rejected\nso promise.all returns even if one promise rejects whereas all settled\nreturns after all promises have completed even if one or more promises\nreject the next method is promise dot raise\nthis method returns a promise that fulfills or rejects as soon as one of\nthe promises fulfills or rejects with the value or reason from that promise\nin the example we have here even though both promises resolve\npromise 2 results in 100 milliseconds whereas promise 1 results in 500\nmilliseconds so the value result from promise 2 is the value promise dot raise will get\nwhich is log to the console on line 10. the output is the string 2 that you can\nsee here so promise dot all promise dot all settled and promise dot raise\nthese are some of the static methods to keep in mind for an interview\nwell with that we come to the end of the discussion about promises in javascript\nin the next lecture let's take a look at how asynchronous code can be further improved with async await"),(0,a.kt)("p",null,"async & await"),(0,a.kt)("p",null,"welcome back in the previous two lectures we learned about promises in javascript\nwe learned about the basic syntax and how to add success and failure callbacks\nwe also learned how chaining promises resolves the problem we had with callback hell\nalthough it's clear that promises improve the readability of your asynchronous code\nthere is a way to improve it even further that is by using the async await\nkeywords introduced in es2017 the async await keywords allow us to\nwrite completely synchronous looking code while performing asynchronous tasks\nbehind the scenes in this lecture let's understand more about async and await\nlet's start with the async keyword the async keyword is used to declare\nasync functions what are async functions async functions\nare functions that are instances of the async function constructor\nnow what is special about async functions well unlike normal functions async\nfunctions always return a promise let's understand this with an example\nhere you can see that we have a simple normal function greet which returns hello\nwhen you run this function in the browser console it locks hello nothing that we don't already know\nlet's convert this function into an async function you do that by declaring the function\nwith the async keyword so async function greet and then the function body\nso we now have async function greet which returns hello\nhowever if you run this function in the browser console you're going to see\npromise fulfilled followed by hello logged fulfilled is the promise status and\nhello is the promise value like i mentioned an async function\nalways returns a promise if you don't explicitly return a promise\nthe async function will automatically wrap the value in a resolved promise\nso you could if you wanted to rewrite the function body as async function grid\nreturn promise dot resolve hello and output would be the same\nin order to actually consume the string value when the promise fulfills we would use then function on the promise\ninstance it's a greet dot then which receives the promise value which you then log to the\nconsole now you can see that the output on line 5 is the string hello\nso the async keyword ensures that the function returns a promise\nbut it's not just that the real advantage of async functions\nbecome evident when you combine it with the await keyword let's understand more about this await\nkeyword the first point is that the await keyword can be put in front of any async\npromise based function to pause your code until the promise settles and returns its result\nin simple terms you can say that the await operator makes javascript wait until the promise settles and returns a\nresult the second point about the await keyword is that it only works inside async\nfunctions you cannot use a weight in normal functions let's understand this with an example\nwe have an async function greet within the function body on line three\nwe create a promise that results after one second we store the promise in a variable\ncalled promise in the next line we await the promise\nand assign the returned value to the result variable on line 9 we log the result to the\nconsole which prints hello so what is happening here is that the\nawait keyword basically pauses code execution till the promise settles\nin this example the promise takes one second to settle so after a second the execution resumes\nand hello is logged to the console it's important to note here that the\nawait keyword literally suspends the grid function execution until the promise settles\nand then resumes it with the promise return value the javascript engine can do other tasks\nin the meantime but as far as greet function is concerned there is one second suspension\nwhere no further code will execute if we go back to the promise chaining\nexample we had a look in the previous lecture we can rewrite it using async await in\nthe following way you can see that the code resembles synchronous code and is even more\nreadable than a promise chain in fact error handling is also\nsimplified as you can simply use try catch blocks like you would with synchronous code\nall right the last thing i want to discuss when it comes to async await is sequential versus concurrent versus\nparallel execution it's really important to understand this because you might be unknowingly slowing\ndown your own code consider two simple functions as you see\nhere in this slide both functions return a promise\nthe first function is resolve hello which resolves the string hello after two seconds\nthe second function is resolve world which results the string world after one\nsecond let's use both these functions to understand sequential execution first\nwe have an async function called sequential start where we call both the functions and await on the result\nin this case resolve hello will take two seconds and then hello is logged to the console\nonly then the execution goes to resolve world which takes an additional second\nso after three seconds which is two plus one the string world is logged to the\nconsole now unless your second function is dependent on the first function you\nprobably shouldn't be doing this as there is an unnecessary delay of one second\nthe total time taken to log hello world and sequential start is 3 seconds\nnow let's talk about concurrent execution again you can see that we have an async\nfunction called concurrent start where we call both the functions\nhowever there is a difference this time we go ahead and call both the functions\nand store the result in hello and world but when logging to the console we are wait\nfor the promise to be fulfilled what happens in doing so is that hello\ngets resolved after two seconds and gets logged to the console since world actually results in just one\nsecond by the time hello is resolved world is ready with its value\nso as soon as the execution comes to await world on line six it logs that\nvalue to the console immediately there is no need to wait an additional second\nnow this is probably what you want to be doing when loading parts of a page\nconcurrently fire off all your requests and then display the ui as per your requirement by awaiting in the right\norder the total time taken to log hello world in concurrent start is 2 seconds\nor in other words the longest time taken by a function to resolve\nfinally let's talk about parallel execution if you prefer that individual functions\nare resolved without having to wait for other functions to be resolved you can make use of promise.all and use async\nfunctions as arguments in this example after one second world\nwill be locked to the console and after two seconds total hello would be logged to the console\nso this is a case of running whatever code resolves first\nthe output in this case would be world hello with the total time taken of two\nseconds of course in the parallel function itself if you want to ensure the\nexecution is paused at promise dot all then on line one add the async keyword\nand on line two you need to await promise dot all the resulting output is world hello\nfinally world locks after one second hello locks after two seconds\nand after the promise has been awaited we then log the string finally so javascript waits for all the\npromises to be resolved before moving on to line six so that is about async and await\nthe async and await keywords enable asynchronous promise based behavior to be written in a cleaner style avoiding\nthe need to explicitly configure promise chains of course you don't have to memorize\nthis definition but make sure during an interview your explanation covers the essence of the definition\ntypically this would be a follow-up question after promises so explain that in es2017 async await\nkeywords were introduced to help write async code in a cleaner way\nexplain first about the async keyword how it always returns a promise and then explain about the await keyword which\nwill pause execution till the promise is resolved or rejected\nthe sequential versus concurrent versus parallel execution isn't really necessary but will\ndefinitely give you an edge if you can explain it well during your interview\nin the next lecture let's take a look at a quick exercise related to async await"),(0,a.kt)("p",null,"Event Loop"),(0,a.kt)("p",null,"all right in this lecture let's understand about the all important event\nloop in javascript let me tell you that what do you know about the event loop in javascript is an\nextremely popular question for a senior front-end developer interview\nbut interview aside it is one concept that i would highly recommend you learn\nas early as possible in your career as a front-end dev it will tremendously help you understand\nand write better asynchronous code in javascript\nwe will split this discussion on event loop into four concise lectures\nin this lecture we're going to begin with a small recap about async programming in javascript\nwe will then go through the different parts that are essential to run asynchronous code in javascript\nwe will also see how the different parts work when executing a simple synchronous\ncode snippet in the next three lectures we will understand the same but with\nasynchronous code snippets we've already learned about callbacks\nand promises that make async programming possible but as a senior front-end dev you should\nunderstand how they work internally so in the next lectures we will see how\na set timeout code executes how a promise executes and finally in\npart four how the code that combines all of these topics executes\nby the end of the fourth lecture i guarantee you that you'll have a much better understanding of not only async\njavascript but also javascript in general let's begin with a recap\nif you can recollect from the first lecture on async javascript i mentioned that javascript is a synchronous\nblocking single threaded language i also mentioned that to make async\nprogramming possible javascript alone isn't enough we also need the web browser\nso let's try to understand what are the different parts that come together from javascript and the browser to make async\nprogramming possible the entire model is referred to as the\njavascript runtime environment as part of this environment we first have the javascript engine\nthis comprises of a memory heap and a call stack\nwhenever you declare variables or functions memory is located on the heap\nwhenever you execute code functions are pushed onto the call stack and when the function returns it is\npopped off the call stack a straightforward last in first out implementation of the stack data\nstructure a popular example of a javascript engine is chrome's v8 engine\nif you come across the term v8 engine it is on a very high level referring to\nthis sort of a javascript engine implemented in chrome\nnow the second part of this environment is the browser's web apis for example say timeout promise xhr\nrequest dom etc remember these apis are not\nimplemented in javascript they are features provided by the browser that javascript simply has\naccess to the third part of this runtime environment is what is called a callback\nqueue it is also called a task queue or simply a message queue\nthis cube is a first in first out data structure\nthe fourth and final part important for our discussion is the event loop\nthe event loop has only one job check if the call stack is empty and if\nit is push an item from the queue into the stack\nand we will learn more about these parts while we go over set timeout and promise code snippets\nbut this runtime is what you need to imprint in your mind\nfor the current lecture on synchronous code and the next lecture on said timeout code\nwe don't have to worry about the memory heap so we can further simplify this model\nleaving out the memory heap the call stack the web apis the callback\nqueue also known as the task queue and the event loop are sufficient for\nnow with this model in place we can now go over a simple synchronous code snippet\nand understand how the javascript runtime goes about executing the code\non the left we have a simple code snippet three console.log statements that log\nfirst second and third one after the other there is no async aspect to the snippet\nbut i want you to first understand how the call stack works so on the right hand side we have the\njavascript runtime environment from the previous slide bottom left i also have the browser\nconsole so that we can see the output for the code snippet now let's walk through the code as if\nthe runtime is executing it the thread of execution always starts in\nthe global scope so the global function if you can call it that is pushed onto the stack\nthen on line one we have a console.log statement the function is pushed onto the stack\nand for the sake of understanding the timeline let's assume this happens at one millisecond\nfirst is locked to the console then the function is popped off the\nstack execution comes to line three let's say at two milliseconds\nlog function is again pushed onto the stack second is locked to the console and the\nfunction is popped off the stack finally execution is on line 5\nand at 3 milliseconds function is pushed onto the stack third is logged to the console and the\nfunction is popped off the stack there is no more code to execute and\nglobal is also popped off this is pretty much how synchronous code\nexecution can be visualized with the javascript runtime\nof course we haven't talked about web apis or the callback queue or even the event loop for that matter because that\nis not needed for synchronous code but understanding how the call stack\nworks is really important to understanding asynchronous code as well\nso let's head over to the next lecture where we will understand a code execution with settimeout\nwelcome back in this lecture we are going to visualize how a set timeout code would\nexecute in the javascript runtime environment on the left hand side we have the code\nsnippet three log statements like before but this time the second log statement is\nactually delayed using the settimeout function so on line one we log first to the\nconsole on line three we have the set timeout and inside the callback function we\nlogged second to the console and on line seven we log third to the\nconsole a straightforward code snippet let's understand how the execution\nproceeds we have the runtime again on the right hand side and console on the bottom left\njavascript starts executing in the global scope so global gets pushed onto the stack\nexecution comes to line one at one millisecond console log is pushed\nonto the stack first is logged in the console and the function is popped off the stack\nexecution now moves on to line three at two milliseconds\nthe set timeout function gets pushed onto the stack in the earlier lecture i mentioned that\nsay timeout is not a feature present in javascript it is a web api which we can call from\njavascript so what happens now is that the callback function and the duration are handed\nover to the set timeout web api which is a browser feature javascript then simply pops off the set\ntimeout function from the calls tag because its job is done as far as execution of line 3 is concerned\nthe web api starts its timer for 2 seconds in the background\nat 3 milliseconds javascript proceeds to line 7 pushes the lock function onto the stack\nthird gets logged in the console and the function is popped off the stack\nnow there is no more code in the global scope to execute so the call stack is\nempty two seconds have now passed by\nthe web api knows the timer is up and it has to send the callback function for\nexecution now we know that all functions are executed by pushing them onto the calls\ntag so the callback function also needs to be pushed onto the calls tag\nbut here is the crucial bit the web api cannot directly push a function onto the\ncalls tag and for good reason as well imagine if a function is executing in\nthe call stack and the web api randomly pushes another function on top of the stack\njavascript can do only one thing at a time so it would have to drop whatever it was doing and cater to the new\nfunction on top of the stack as you might have guessed that could lead to total chaos\nso what the web api does is it pushes the callback function into the callback\nqueue the callback function is now waiting to be executed\nand the part that decides whether to push the function onto the call stack or not is the event loop\nthe event loop constantly checks if the call stack is empty and if it is it\npushes the item at the front of the callback queue onto the stack if the call stack is not empty it will\nnot push the item onto the stack that is its only functionality\ncheck call stack check callback you push if call stack is empty\nit is always in this constant loop of following those instructions over and\nover again in our example the event loop says that the call stack is md\nmeaning no code is running in the global scope it is safe to push the callback function\nonto the stack and the event loop does just that but there is one key point here even\nthough a function reference is what the callback queue holds the event loop will push and\nautomatically execute the callback function within the callback function the log\nstatement is encountered so the function is pushed to the call stack\nsecond is logged in the console the log function is popped off\nthere are no more statements to execute in the callback function so that is popped off as well\nno more code to run in the file so the global function as we call it is also popped off the stack\nthe console output is going to read first third and then second as you can\nsee in the bottom left this is how an async code snippet with\nset timeout runs internally now regarding set timeout an important\nquestion during an interview is what happens when the timeout duration is 0 milliseconds\nlet's prepare for that question as well on the left we have the exact code\nsnippet as before but this time the duration is 0 milliseconds\nwe have our runtime as well as the console i want you to pause for a second and try\nguess what the output is if you made your guess let's proceed\nthe execution starts in the global scope which will be pushed on to the call stack\nat one millisecond execution is at line one which pushes the function to the call stack logs first to the console and\npops the function from the call stack now at two milliseconds\nthe execution proceeds to line three where we have the set timeout\nthe callback function and the duration are handed over to the web api\njavascript then simply pops off the set timeout function from the calls tag because its job is done as far as\nexecution of line 3 is concerned the web api now sees that the duration\nis 0 milliseconds that means the callback function has to be pushed into the callback queue\nwhile this is happening in the background at three milliseconds the javascript thread of execution has already reached\nline seven the console.log function is pushed to the call stack\nlet's say at the same time the callback function was pushed to the queue\nnow event loop is on alert since the callback queue has an item\nthe event loop checks if the call stack is empty it is not\nwhich means the callback function cannot be pushed to the calls tag\njavascript proceeds to log third to the console and then pops the function from\nthe top of the stack since the event loop constantly checks if an item is in the queue and if the\ncall stack is empty its condition is satisfied to push the callback function onto the stack\nso at 4 milliseconds the callback function is pushed to the top of the stack and executed\nthe log function is executed and second is logged to the console\nthen log function the callback function and global are all popped from the top\nof the stack as you can see a set timeout of 0 milliseconds doesn't mean the statement\nis executed immediately it has to wait for its turn or in other words it has to wait for the\ncall stack to be empty if there is a while loop that runs one million iterations for five minutes then\nset timeout with zero milliseconds duration has to wait and execute after the five minutes\nthis brings me back to the point i had mentioned in the set timeout lecture the duration parameter to set timeout is\nthe minimum delay and not the guaranteed delay\nright i hope that makes your understanding of set timeout much better\nin the next video with a similar model in place let's understand how the execution of a promise is in javascript\nin this lecture we are going to visualize how a promise-based code would execute in the javascript runtime\nenvironment on the left-hand side we have the code snippet\non line 1 we log a string first to the console on line 3 we have the fetch api\nif you're new to this fetch is a web api that lets you perform network requests like get post put\ndelete and so on the argument to fetch is the url that we want to make a get request to\nfor our example i am using a udemy url it's not an actual api endpoint but for\nthis lecture let's assume it's an endpoint that returns a list of courses for a given instructor\nwe have passed in vishwas as the instructor so the api would respond with a list of my courses\nbut what is the key point about the fetch api is that it returns a promise\nwe store that in a constant called promis then on line 4 we add the success\ncallback using then method we receive the promise value which we\nsimply log to the console promise value is followed by the value\nline 8 we have another log statement that locks the string second to the console\nnothing too complex as you can see let's understand how the execution\nproceeds on the right hand side we have the model from the previous lecture\nwe have the call stack the web browser apis the callback queue also known as the task queue\nand finally the event loop to understand the execution of a promise-based code snippet though\nwe need two more parts to our runtime model first is the memory heap and second is\nanother cue called the microtask queue let's see how all these parts come\ntogether while executing the code also similar to the previous lecture we\nhave the console in the bottom left to visualize the log statements\nall right let's begin executing the code javascript starts execution in the\nglobal scope so global gets pushed onto the stack execution comes to line one\nat one millisecond console.log is pushed onto the stack first is logged in the console\nand the function is popped off the stack execution now moves on to line three\nat two milliseconds the fetch function gets pushed onto the stack\na minute ago i mentioned that fetch is not a feature present in javascript but\nis a browser api so what happens now is that the fetch function call and the url are handed\nover to the web api which is a browser feature unlike said timeout though\nfetch leaves behind a promise object in javascript memory\nand if you remember a promise will have a promise value and we can attach\nsuccess and failure callbacks that will be invoked when the promise is fulfilled or rejected\nyou can see properties corresponding to that in the promise object we will talk more about this in just a\nbit but from the fetch api point of view i want you to keep in mind that it has\nconsequences both in the browser as well as in javascript\nthe fetch network request is now started in the background but we all know that fetching data is\nnot instantaneous for our example let's assume the fetch\napi will take 2 seconds to return data from the udemy endpoint\nwhile that is happening in the background you can notice that the call stack is empty once again\nwhich means the thread of execution is now at line four\nat three milliseconds promise dot then is pushed to the call stack with the callback function as its\nargument the callback function here is the arrow function you see in the code snippet\nthen function has only one purpose to push its argument into the on\nfulfillment array in the promise object that completes line 4 and at 4\nmilliseconds execution now proceeds to line 8 pushes the lock function onto the stack\nsecond gets logged to the console and the function is popped off the stack\nnow there is no more code to execute in the global scope so the call stack is empty once again\ntwo seconds have now passed by which means the fetch api now has the data\nretrieved from the udemy api endpoint once it has the data which is the list\nof courses for the instructor the fetch api will set that as the\npromise value in javascript now here's the cool thing\nwhen the promise value is updated javascript will automatically execute\nall the functions listed in the on fulfillment array in our example we just have the one\ncallback function which needs to be executed but here's the thing\nonce again the function needs to be pushed to the call stack to be executed but javascript cannot directly push the\ncallback function onto the stack as that would lead to chaos instead the callback function is passed\ninto the microtask queue along with the promise value the event loop comes into picture again\nit checks if the call stack is empty and if there is an item in the micro task queue\nthe condition is satisfied and the callback function is pushed onto the call stack with the promise value as its\nargument the thread of execution now goes inside the callback function\nthe log statement is encountered which is pushed on top of the stack\npromise value is courses is locked in the console and the lock function is popped off\nthe callback function execution is done so that is popped off the stack as well\nfinally there is no more code to run and the memory is also garbage collected\nbefore i remove the promise object though let me clear one point\nin our example we assumed the promise would resolve successfully\nand hence the on fulfillment callback was executed but promises can also be rejected\nso in the code snippet if promise dot catch was invoked the callback function\nto catch would be inserted into the on rejected array in javascript and when the fetch api failed because of\nsome reason the functions in the on rejected array are executed automatically the event loop will handle\nthe rest so this is how an async code snippet\nwith a promise runs under the hood now one question you might have is why\ndo we have two cues a task queue and microtask queue\nwell let's understand more about the two cues in the next lecture\nin the previous two lectures we learned about the javascript runtime and how a simple async code snippet that\ninvolves set timeout and a simple async code snippet that involves promise\nexecute in this lecture let's understand how a code snippet that involves both a set\ntimeout and a promise will execute this is really important so please make\nsure you understand well on the left hand side we have the code snippet\nlet's go through what we have here on line one we have the set timeout function with the duration of zero\nmilliseconds in the callback function passed to set timeout we simply log the string first\nto the console on line 5 we have the fetch api call\nwhich returns a promise we store that in a constant called promise\nthen on line 6 we add the success callback using then\nmethod within the success callback function we receive the promise value which we\nsimply log to the console on line 10 we have an interesting bit of code\nit's a while loop which iterates 1 billion times the curve within the while loop itself\nhas no significance what we are trying to achieve is block the javascript execution thread for a\nfew seconds for this example let's assume that our while loop takes three seconds which\nbasically means the execution thread is busy and blocked for 3 seconds\nthis piece of code is really important for this example finally on line 14 we have a console.log\nstatement that logs the string second to the console\nnow that we understand the code let's understand how the execution proceeds\non the right hand side we have the runtime model from the previous lecture we have the javascript memory call stack\nweb browser apis event loop micro task queue and the task queue\nwe also have the console in the bottom left to visualize the log statements\nall right let's begin executing the code javascript starts execution in the\nglobal scope so global gets pushed onto the stack execution comes to line one\nat one millisecond the set timeout function gets pushed onto the stack since set timeout is a browser feature\nthe callback function and the duration are handed over to the web api\nset timeout function is also popped off the stack the web api sees that the duration is 0\nmilliseconds and immediately pushes the callback function into the task queue\nthe callback function thinks it will soon get to execute on the call stack\nbut not so fast there are still statements to execute in the global scope\nso execution now moves on to line five at two milliseconds the fetch function\ngets pushed onto the stack the function call and the url are handed\nover to the browser to make the network request fetch also leaves behind a promise\nobject in javascript memory the fetch network request is started in\nthe background and for our example let's assume the fetch api will take 2 seconds\nto return data from the udemy api endpoint while that is happening in the\nbackground the thread of execution has already moved on to line 6.\nso the callback function still has to wait for its turn at three milliseconds\npromise dot then is pushed onto the call stack with the callback function as its\nargument the callback function here is the arrow function you see in the code snippet\nthen function has only one purpose to push its argument into the on\nfulfillment array in the promise object at four milliseconds\nthe while loop begins executing there are 1 billion iterations which\nwill run for 3 seconds during this while loop execution\nat 2 seconds the fetch api has the data retrieved from the udemy\napi endpoint once it has the data which is the list of courses for the instructor\nthe fetch api will set that as the promise object's value in javascript\nwhen the promise value is updated javascript will automatically execute the callback function listed in the on\nfulfillment array the function needs to be pushed onto the call stack to be executed\nbut as we already know javascript cannot directly push the callback function onto\nthe stack as that would lead to a lot of problems instead the callback function is passed\ninto the micro task queue along with the promise value the task queue and the micro task queue\nboth have an item to be pushed onto the call stack however the call stack is not empty so\nboth of them have to wait for their turn the time advances to three seconds and\nwhile loop is still executing at 3.4 seconds that is three seconds\nafter the while loop started the while loop completes and is popped off the stack\nnow can the callback functions execute no there is one more line of code to\nexecute first so at 3.41 seconds execution is at line 14. the log function is pushed onto the stack the string second is logged in the\nconsole and then the function is popped off the stack\nnow finally we have no more code to run and the call stack is empty\nboth the queues contain an item and the call stack is also empty which means the event loop can now push\nan item from the queue onto the stack but the question is which item to push\nwell the set timeout callback was the first one to be queued in the task queue and it has been waiting there for three\nand a half seconds now so it would be correct to first execute that right\nwell that is where we are wrong javascript gives a priority to the\nmicrotask queue over the task queue so it is the callback function from the\npromise that gets pushed onto the call stack first within the callback function we have the\nlog function which logs the promise value to the console and then gets popped off\nthe callback function also gets popped the call stack is empty again and the\nmicrotask queue is also empty which means the callback function in the\ntask queue is now pushed onto the stack the lock function within the call stack\nis then pushed which logs first to the console and then popped off the stack\nthe callback function is also popped off and there is no more code to execute\nthis is how a code snippet featuring both set timeout and a promise will run\nunder the hood when it comes to the event loop it has two main tasks\ncheck the call stack if empty push item in the micro task queue onto the calls tag if the micro task queue is also\nempty push item from the task queue onto the calls tag repeat this forever\nall right with that i hope you now have a clear understanding of the event loop and how to explain it during an\ninterview"))}d.isMDXComponent=!0}}]);