"use strict";(self.webpackChunkfundamentals=self.webpackChunkfundamentals||[]).push([[5980],{3905:(e,t,n)=>{n.d(t,{Zo:()=>l,kt:()=>f});var o=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,o,i=function(e,t){if(null==e)return{};var n,o,i={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var h=o.createContext({}),c=function(e){var t=o.useContext(h),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},l=function(e){var t=c(e.components);return o.createElement(h.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},w=o.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,h=e.parentName,l=r(e,["components","mdxType","originalType","parentName"]),u=c(n),w=i,f=u["".concat(h,".").concat(w)]||u[w]||d[w]||a;return n?o.createElement(f,s(s({ref:t},l),{},{components:n})):o.createElement(f,s({ref:t},l))}));function f(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,s=new Array(a);s[0]=w;var r={};for(var h in t)hasOwnProperty.call(t,h)&&(r[h]=t[h]);r.originalType=e,r[u]="string"==typeof e?e:i,s[1]=r;for(var c=2;c<a;c++)s[c]=n[c];return o.createElement.apply(null,s)}return o.createElement.apply(null,n)}w.displayName="MDXCreateElement"},9088:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>r,toc:()=>c});var o=n(7462),i=(n(7294),n(3905));const a={sidebar_position:2},s="Advanced JavaScript",r={unversionedId:"3 JavaScript/2 Advanced JavaScript",id:"3 JavaScript/2 Advanced JavaScript",title:"Advanced JavaScript",description:"Intro",source:"@site/docs/3 JavaScript/2 Advanced JavaScript.md",sourceDirName:"3 JavaScript",slug:"/3 JavaScript/2 Advanced JavaScript",permalink:"/fundamentals/3 JavaScript/2 Advanced JavaScript",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"JavaScript",permalink:"/fundamentals/3 JavaScript/1 Javascript"},next:{title:"Asynchronous JavaScript",permalink:"/fundamentals/3 JavaScript/3 Asynchronous JavaScript"}},h={},c=[],l={toc:c},u="wrapper";function d(e){let{components:t,...n}=e;return(0,i.kt)(u,(0,o.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"advanced-javascript"},"Advanced JavaScript"),(0,i.kt)("p",null,"Intro"),(0,i.kt)("p",null,"this video is sponsored by tascade a real-time organization and collaboration\nplatform make sure to check the description for a discount on your subscription\nhey everyone my name is vishwas and welcome to this crash course on advanced javascript\nin this crash course we will understand some of the advanced topics in javascript"),(0,i.kt)("p",null,"Before we begin"),(0,i.kt)("p",null,"before we begin let me go over a few points first i would like to mention this\ncourse is a continuation of the javascript fundamentals crash course\nif you are new to javascript please watch that video before proceeding\nalso if you're someone who is already familiar with advanced javascript concepts\ni would suggest you wait for the asynchronous javascript crash course\nsecond we're going to cover concepts that you as a front-end developer should know\nit is not an exhaustive list but the topics we will cover are required for any front-end interview you might appear\nfor and most of the topics also find daily usage in your work as a\ndeveloper so we will be covering a limited number of topics but they all are very\nimportant third this video unlike other videos in my channel is a crash course and is\nlonger in length that doesn't mean you have to sit through the entire video at once\ntake it easy pause when necessary and most importantly make sure you code\nalong with me as that is the best way to learn by the end of this video you will have a\nsolid understanding of the advanced concepts in javascript"),(0,i.kt)("p",null,"Concepts covered"),(0,i.kt)("p",null,"all right with these points in mind let's go over the topics we will be learning in this video\nwe're going to start off from where we left off in the fundamentals crash course and that is about scope\nwe will specifically look at nested functions scope which will then take us to understanding closures in javascript\nnext we will learn about the concept of carrying this is followed by the all important\nthis keyword we will then learn about prototype and prototypal inheritance\nthat is followed by learning about classes iterators and finally generators\nwe will save the async javascript concepts for the next video if you have had difficulty understanding\nany of the listed topics here then you are at the right place"),(0,i.kt)("p",null,"Setup"),(0,i.kt)("p",null,"now then for some\nsetup we are going to reuse the setup from the previous crash course so make\nsure you have node.js and vs code installed\nopen vs code inside a folder of your choice i have created a folder called advanced\njavascript and within the folder create a file called main dot js\nopen the terminal so view terminal\nand run node dash dash version if you see the version number in your\nterminal we are good to go"),(0,i.kt)("p",null,"Nested function scope"),(0,i.kt)("p",null,"alright let's begin by revisiting the\nconcept of scope in javascript\nin the fundamentals crash course we learned about three types of scope\nblock scope which dictates that variables declared inside a pair of curly braces cannot be accessed from\noutside the block function scope which dictates variables declared inside a function cannot be\naccessed from outside the function and finally global scope which is the scope outside a top level block or\nfunction of code we also learned that globally scoped variables can be accessed inside a block\nor function we also had look at examples related to each of these scopes\nin case you missed it please watch the last 10 to 15 minutes of the fundamentals crash course for continuity\nnow in the advanced crash course let's learn about a nested functions scope\nwith an example in main.js let's declare a variable a\nand initialize it to 10 in the global scope next let's define a function called\nouter and within the body of the function\ndefine a variable b and initialize it to 20.\nwithin this function let's define another function called inner\nand yes in javascript it is possible to define a function within a function\nso function inner and within the inner function let's declare another variable c\nand initialize it to 30. but then log a b and c to the console\nwithin the inner function a comma b comma c\nnext within the outer function we invoke the inner function\nfinally we invoke the outer function\nif we save the file and run the code node main\nwhat do you think is logged in the terminal you can see the output is 10 20 and 30.\nlet's understand this output from the javascript engine point of view\nwe can directly dive into the log statement on line 6. javascript basically has to look up for\nvalues of a b and c let's start with c javascript checks if\nc is defined in the inner function scope it is and its value is 30. so 30 is\nlogged in the terminal next it looks for b it checks if the\nvariable b is available in the inner function scope it is not\nso it goes one level up and checks in the outer function scope\nis the variable b present in the outer function scope it is and its value is 20. so 20 is\nlogged in the terminal finally we have the variable a\njavascript checks if the variable is present in the inner function scope\nit is not it then checks if the variable is present in the outer function scope\nit still doesn't find it it moves one more level up and reaches\nthe global scope it checks again if the variable is present in the global scope\nit is and its value is 10 which is logged to the terminal\nso the resulting output is 10 20 and 30.\nnow this is an example of lexical scoping which describes how javascript resolves\nvariable names when functions are nested when we have nested functions\njavascript variable lookup starts with the innermost function where we are trying to access the variable\nand moves outward until it reaches the global scope but the bottom line i want you to\nremember is that nested functions have access to variables declared in\ntheir own scope as well as variables declared in the outer scope"),(0,i.kt)("p",null,"Closure"),(0,i.kt)("p",null,"all right with this understanding of nested functions scope we are now ready to proceed to the second concept in this\nadvanced javascript crash course which is closures\nnow what exactly is a closure according to mozilla docs\na closure is the combination of a function bundled together with references to its surrounding state\nclosures are created every time a function is created at function creation\ntime now i refer to mdn docs for most things\nrelated to javascript but this definition doesn't really help me understand what a closure is with the knowledge of\njavascript i have so far so let's head back to vs code and understand what exactly is a closure in\njavascript i will then describe closure in simple terms for you to remember\nin the example about nested function scope we learned that nested functions\nhave access to variables declared in their own scope as well as variables declared in the\nouter scope let's now look at a more simplified version of this example\ncomment out the code we have written so far let's start over we define a function called outer\nwithin the function body we declare a variable counter and initialize it to zero\nwe also define a nested function called inner\nwhere we increment the value of counter\nand then log that value right after the function definition\nwe invoke the inner function inside the outer function\nfinally we invoke the outer function now if you were to run this\ncode what do you think is logged in the terminal node main\nand we can see one this should be clear by now because of how nested functions scope works in\njavascript when the variable counter is encountered within the inner function the javascript\nengine checks if counter is present in the inner function scope it is not\nit then checks the outer function scope the variable is present and it\nincrements the counter value by one and then the new value is locked to the\nterminal which is one seems all right so far\nnow let's invert the outer function twice if you run the code what do you think is\nlogged in the terminal the answer is one and 1.\nthis is because with every new invocation of the function a temporary\nmemory is established and we have a new counter variable initialized to 0 and\nthen incremented hence every outer function call\nwill always print 1 to the console if this is clear let's move on to a\nslight variation of this code at the moment we define the inner\nfunction and invoke it within the outer function let's say we don't necessarily want to\ninvoke the inner function right away instead we want to return the function\nand invoke it at a later point in time in javascript it is possible to return a\nfunction from other functions so let's return inner\nin doing so we can assign the result of invoking out the function to a variable\ncalled fn so const fn is equal to\ninvoking the outer function and this result is the inner function\nso let us now invoke the fn function twice\nfn parentheses fn parentheses\nremember all we are doing is instead of executing the inner function from within\nthe outer function we are returning it and then invoking the function twice\nnow if we were to run the code what do you think is logged to the console\nnode main and you can see the answer is one and\ntwo now that's interesting isn't it we would expect the output to be one and one but\nit is one and two this is because of the concept of closures in javascript\nhere is a definition that i find is more easier to understand\nin javascript when we return a function from another function we are effectively returning a\ncombination of the function definition along with the function's scope\nthis would let the function definition have an associated persistent memory\nwhich could hold on to live data between executions that combination of the function and its\nscope chain is what is called a closure in javascript\nwith this definition in mind let's try to break down the example we have at hand\nnow i mentioned that the closure is created when a function is returned from another function\nif you take a look that is precisely the scenario we have\non line 18 we are returning the inner function from the outer function\nand as it turns out in such a scenario javascript doesn't just return the inner\nfunction it returns the inner function as well as its scope\nin our example the function scope has just one variable called counter\ninitialized to zero so we have the function inner bundled together with the variable\ncounter which is together termed as a closure\nand in such situations the function will persist or remember the value of the\ncounter variable so when we invoke the fn function for the first time\ncounter is incremented to 1 and the value is logged in the terminal\nbut the fn function though remembers that the counter value is 1.\nso the next time we invoke it it increments the counter value to one plus\none which is two that is the reason we see output one and\ntwo that is how closures work in javascript\nthe key point to keep in mind is that with closures an inner function has\naccess to variables in the outer function scope even after the outer function has finished\nexecution you can see in our example that when we invoke the outer function\non line 20 it completes its execution but the inner function\nstill has access to counterweightable which is actually a variable defined in\nthe outer function scope now i get it if this is a little difficult to understand\nmy advice would be to re-watch the concept two or three times and it will\nfor sure start to make sense now if you've understood closures"),(0,i.kt)("p",null,"Currying"),(0,i.kt)("p",null,"the next topic to learn is function carrying the best way to understand function\ncarrying is with an example so that's the approach we will take\nlet's start with the definition what is function carrying\ncurrying is a process in functional programming in which we transform a function with multiple arguments into a\nsequence of nesting functions that take one argument at a time\nso if we had a function f of a comma b comma c we transform it into f of a of b of c\nit is important to note that curry doesn't call a function it simply transforms it\nlet's head back to vs code and understand this with a simple example\nlet's define a function sum which takes three parameters a comma\nb comma c and returns their sum\nto call or invoke this function we write the function name followed by\nparentheses and within parentheses we specify the arguments\nlet's go with two comma three comma five which correspond to a comma b comma c\nif we were to run this code node main we get the output 10.\nnow carrying this sum function means that we need to transform sum from\ncalling it with all three arguments to calling it with one argument at a time\nso from sum to comma 3 comma 5 we should transform it to sum\n2 3 5 one argument at a time\nthe way we do that is by nesting functions where each function takes one\nargument at a time let's understand the code we start off with a function called\ncurry and this function will accept a function as its argument\nand return the carried version of the function now for each of the three arguments we\nreturn individual functions that accept one argument at a time\nand the functions will be nested one inside the other so\nthe curry function will return a function which accepts an argument a\nthis function in turn will return a function which accepts argument b\nthis function in turn will return a function which accepts argument c\nwe are transforming from accepting three arguments at a time to one argument at a\ntime now when we have broken down the function into nested functions we check\nif we have all the necessary arguments to run the given function in our case we have a b and c so we have\nall the arguments so now from the innermost function we\nreturn the actual passed in function with all the necessary arguments\na comma b comma c with this curry function in place\nwe can now write const curried sum\nis equal to call the curry function passing in the sum function\nin the next line console log and we can invoke the carried sum function\npassing in one argument at a time so correct sum of 2\nof 3 of 5.\nrun node main and the output will still remain 10.\nnow if this syntax doesn't look that different from what you've been doing all this while let me break this down\nconst add 2 is equal to curried sum and we pass in\nto const add 3 is equal to\ncall add 2 passing in a value of 3\nthen const add 5 is equal to call add three\npassing in five finally log to the console\nadd five the three parentheses can be broken down\ninto three separate function calls the first function takes the first\nargument second takes the second argument and third takes the third argument then\ncomputes the sum of all the three arguments and returns the result\nso this will just be add five instead of invoking at five\nrun node main and we see 10 from both the log statements\nwe have transformed a function with multiple arguments into a sequence of\nnesting functions that take one argument at a time\nnow carrying is used to compose reusable functions for example you can create functions\nlike log info log error log now etc\nwhere one or more arguments are set and you get to choose the remaining arguments\ncarrying makes composing new functions very easy if you have understood the general\nconcept about carrying i would recommend you take a detour google more about\nfunction carrying and get an understanding of the practical applications"),(0,i.kt)("p",null,"this keyword"),(0,i.kt)("p",null,"all right we're now going to move on to one of the most confusing parts of javascript which is this keyword\nthe javascript this keyword which is used in a function refers to the object it belongs to\nit makes functions reusable by letting you decide the object value\nand this keyword value is determined entirely by how a function is called\nnow if that doesn't make sense let's understand with a few examples how to use this keyword and how its value\nchanges based on the function call back in vs code let's define a function\ncalled say my name which has one parameter\nname and logs to the console my name is followed by the name passed\nin looking at the function if i were to ask\nyou what would this function log to the console you would say we can only determine that\nlooking at the function call if i call the function passing in\nwalter white you would say the output is hello my name is walter white\nif i call the function passing in heisenberg\nyou would say the output is hello my name is heisenberg\nso you can determine what is logged to the console by how a function is called\nand this is the same with this keyword you can determine the value of this\nkeyword by how a function is called now there are four ways to invoke a\nfunction in javascript and determine the value of this keyword\nimplicit binding explicit binding new winding and finally default binding\nlet's look at examples for each of them first implicit binding\nimplicit binding rule will tell you what this refers to most of the time\nconsider an object person with a property called name\nset to vishwas also a function or a method to be more\nprecise called say my name which logs this dot name to the console\nmy name is dollar curly braces and we evaluate this dot name\nto invoke the function we use the dot notation so person\ndot say my name we now know how the function is called\nwhich means we now have what we want to determine this keyword inside the say my\nname function the implicit binding rule states that when a function is invoked with the dot\nnotation the object to the left of the dot is what this keyword is referencing\njavascript will now treat this dot name as person dot name\nwhich is equal to the string vishwas and the output if i run node main\nis my name is vishwas this is the implicit binding rule\nthe second rule to determine this keyword is explicit binding\nconsider the same function say my name but this time the function is separated\nfrom the person object so function say my name and we log to\nthe console my name is this dot name in this scenario\nwe have to explicitly specify the context when the function is called\nto do so we can use the call method in javascript every function has a\nbuilt-in method named call which allows you to specify the context with which a\nfunction is involved so to invoke say my name with the person object context we have\nto write say my name dot call with person as the argument\nthe first argument passed to call is what this keyword inside say my name is\nreferencing if you run node main the code will once again output my name\nis vishwas to the terminal so this is the second rule which is\nexplicit binding the third rule for determining this in a\nfunction is the new binding in javascript we can invoke a function\nwith the new keyword and in such a scenario the function is invoked with this keyword referencing an\nempty object so consider a function called person\nwhich accepts a name within the function we set this dot name\nis equal to the passed in name with this function we can now create\nmultiple persons or people passing in different names each time\nso const p1 is equal to new person and the name can be vishwas\nand similarly const p2 is equal to new person\nyou pass in batman this person function right here is what\nis known as a constructor function as we can create multiple persons from this\nfunction now when we invoke a function with this\nnew keyword javascript under the hood will create a new empty object that this keyword will\nreference so within function person i'm going to\nadd as a comment this is equal to an empty object\nyou can then add properties to the object using this followed by the dot notation\nso this dot name is equal to name we are not creating this empty object\nthe new keyword internally does this when function person is invoked with the\nnew keyword the new keyword also does a few other things\nbut from at this keyword point of view i just want you to remember the following line\nwhen a function is invoked with the new keyword within the function this keyword will always reference a new\nempty object so if we log p1 dot name and p2 dot name\nrun node main we see vishwas and batman in the terminal\nall right the fourth and final rule is the default binding which is the\nfallback binding if none of the other three rules are matched\nso consider the same say my name function let's call it as you would normally call\na function say my name with parentheses as you can see there is no dot notation\nno call method or no new keyword as well if we simply invoke say my name\nwhat do you think the output is run node main and you can see it is my name is\nundefined so if none of the three rules are satisfied javascript will default to the\nglobal scope and set this keyword to the global object\nin the global scope javascript will try to find a variable called name\nsince it doesn't find it this dot name is undefined\nif you were to have the variable name in the global scope however the const name is equal to superman\nif it were to be a browser but since it is node\nthis dot name is equal to superman run node main\nyou can see the output is my name is superman so the fourth binding is the default\nbinding where this keyword will rely on the global scope\nas you can see with this keyword you can introduce a dynamic value within the same function\nwhat you should know is that when multiple rules can be applied to figure out this keyword\nnew binding takes top priority followed by explicit binding followed by implicit\nbinding followed by default binding so this is how\nthis keyword works in javascript it lets you specify the execution\ncontext and its value is pretty much determined by how the function is invoked"),(0,i.kt)("p",null,"Prototype"),(0,i.kt)("p",null,"all right next let's take a look at another concept that is usually difficult to understand which is the\nconcept of prototype when it comes to prototype there is a\nlot of terminology and when we try to understand everything it may lead to confusion and us losing interest in the\ntopic especially as beginners in this crash course we will learn with\na simple example why and how prototype works in javascript\nlet's begin by defining a function called person\nfunction person has two parameters first name and last\nname and within the function we're going to write this dot first name\nis equal to the passed in first name and this dot last name is equal to the\npast in last name we can now create instances of this\nperson function using the new keyword so const p1 or person one\nis equal to new person we pass in bruce\nwayne similarly const person 2\nis equal to new person we pass in clark and kent\nnow as you already know javascript is a dynamic language so it allows us to attach new properties\nto an object at any given time so on person one we can attach\nperson one dot get full name which is going to be equal to a function\nwhich returns this dot first name\nfollowed by this dot last name you can also use the template literal\nsyntax for string concatenation now what you should know here is that\nget full name property is specific to just person one\nif we log person one dot get full name to the console\nrun node main we see bruce wayne logged in the terminal\nhowever if we run person 2 dot get full name and run node main\nwe get an error person.getfullname is not a function\nnow what if we wanted to attach a property or a method that should be\napplied to every instance of this person function in our example getfullname is a function\nthat benefits us by being available on all instances of the person function\nsince it is generic it is not specific to just person 1. it\nwould work on person 1 2 3 or even person 100\nwell this is where prototype comes into picture in javascript\nevery function has a property called prototype that points to an object\nwe can make use of that prototype object to determine all our shareable\nproperties so instead of person one dot get full name\nwe change it to the person function dot prototype\ndot get full name now if we log\nperson1 dot getfullname and person2.getfullname\nrun nodemain we see bruce wayne and clark kent in the terminal\nyou have defined the getfullname function once but it is available on every instance of the person function\nagain on a sidenote the function that is used with the new keyword is called a constructor function"),(0,i.kt)("p",null,"Prototypal inheritance"),(0,i.kt)("p",null,"now one use of prototype is to share properties and methods across instances\nthe other use which is pretty significant as well is inheritance\nin javascript inheritance is supported through the concept of prototypes and is\nreferred to as prototypal inheritance let's understand how it works\nfor our example we're going to create a superhero that is supposed to inherit properties and\nmethods from person so a superhero will have a first name\nlast name and a getfullname function but apart from that a superhero will\nalso have a property called eastsuperhero set to true and a fight crime function that locks a\nmessage to the console let me walk you through the code\njust going to rearrange the code so there is continuity\nand now we are going to begin by defining the superhero function\nfunction superhero and we add one property called is\nsuperhero and we set it to true we also defined the fight crime function\non the prototype so superhero dot prototype\ndot fight crime is going to be equal to a function\nwhere we log to the console fighting crime\nwe can now create an instance of this superhero function const\nbatman is equal to new superhero\nhowever batman only has access to ease superhero and fight crime\nwe want batman to also have a first name a last name and the getfullname function\ninstead of duplicating the code we have written for person let's inherit them\nfirst let's inherit the first name and last name properties\nsuperhero function will now accept two parameters fname\nand a name these values though need to be passed\ninto the person function but the person function should be invoked with this keyword\npointing to this object from superhero function\nand if you remember from the section on this keyword we can call a function by specifying\nwhat this keyword should point to using the call method\nso person dot call and we pass in\nthis keyword which is created inside the superhero function as its first argument\nsecond argument will be fname third argument will be l name\nso this keyword in person will now refer to this keyword in\nsuperhero fname and a name get assigned\nand first name and lastname properties are now inherited by superhero\nnow to inherit the get full name method we're going to use object dot create\nwhich is a method that will delegate to another object on failed lookups\nso superhero dot prototype is equal to object dot create\nand we pass in person dot prototype so what this does is when you try to\naccess patman dot get full name javascript checks the prototype object\nof superhero it doesn't find it however it sees that the prototype\nobject has a chain to person dot prototype created because of this object dot\ncreate method it checks to see if person.prototype has\na getfullname method it does and it will execute that method\nthis is how the method is inherited through the prototype chain hence the name prototypal inheritance\nso if you now pass in bruce and wayne\nwhile creating batman and log batman dot get full name\nrun node main and we see bruce wayne locked in the terminal batman superhero has inherited get full\nname from person the method will access this dot first\nname and this dot last name which are also inherited by the superhero function\nnow one last bit of cleanup we need to do is to ensure superhero\ndot prototype dot constructor is equal to superhero\notherwise javascript thinks that a superhero is created from person which\nis incorrect run the code again and we still see bruce wayne\nsuperhero has inherited properties and methods from person"),(0,i.kt)("p",null,"Class"),(0,i.kt)("p",null,"all right for our next topic we're going to learn about the class keyword which\nwas introduced in 2015. a minute ago we learned about prototypal\ninheritance if you're coming to javascript from a language like c plus plus or java\nit might be very confusing you would be more used to class based\ninheritance to somewhat relate to that classes were introduced in 2015.\nhowever the class syntax does not introduce a new object oriented\ninheritance model in javascript classes are primarily syntactical sugar over the existing\nprototypal inheritance let's learn how it works by rewriting\nthe prototypal inheritance code with classes let's start with this person function\nfirst change function person becomes class person\nthe initialization of the name argument to this object gets moved into a\nconstructor so constructor accepts first name and\nlast name and within the constructor this dot first name is equal to fname\nthis dot last name is equal to l name\nsecond and final change all the methods on the prototype object\nare rewritten as methods within the class\nso say my name is a function where we return\nthis.firstname followed by this.lastname it is as simple as that\nwe can now comment out the previous code and create instances of this person\nso const class person one is equal to new person\nand we pass in bruce and wayne as arguments we can now log class p1\ndot say my name to the terminal and we see bruce wayne being logged\nso we can create an instance and access the properties and methods like before\nnothing changes the class keyword simply makes the syntax better for the code we\nalready had in place let's now rewrite superhero which\ninherits from person two keywords take care of the entire\ninheritance and those two keywords are extends and super\nwe specify that class superhero extends class person\nand in the constructor we accept\nfirst name and last name and we invoke the super method that\njavascript provides us passing in fname and lname\nthis will call the person class constructor\nonce we call super we set the superhero properties and methods in the class\nthis dot is superhero is equally true\nand then we defined the fight crime method console.log\nfighting crime but this simple class syntax pretty much\nis all we have to write let me now create a new instance so\nconst batman is equal to new superhero passing in bruce and wayne\nand we log batman dot say my name\nwhich will print bruce wayne again let me reiterate classes are just\nsyntactical sugar over what was already existing in javascript\nso make sure you understand how to create a class how to initialize properties\nhow to add methods how to create an instance of the class how to inherit using the extents and\nsuper keywords that is pretty much all you have to know about the class keyword from a\nbeginner's point of view"),(0,i.kt)("p",null,"Iterables and iterators"),(0,i.kt)("p",null,"alright let's move on to the pen\nultimate topic in this crash course which is iterables and iterators\ni'm going to begin by setting some context about iteration in javascript\nbefore 2015 we had three looping constructs for loop while loop and do while loop\nlet me show an example of how to iterate and access data with a string and array\ntype using the for loop on the left hand side you can see that\nwe have stored the string vishwas in a variable called sdr\nand we basically want to log every character in the string to the console\nsimilarly on the right hand side the array is a collection of items which\nis nothing but the characters of the string we have already seen we again want to log to the console each\nitem in the array now this form of iteration has two\ndifficulties if i can call it that first to apply some functionality on\neach element in the string or each item in the array we first need to figure out how to\naccess that element we need to create a new variable i keep track of it ensure it satisfies a\ncondition and finally increment that value of i to access the next element in\nthe collection if there are nested for loops we have to do this all over again with a second\nvariable so we would have difficulty in accessing the element itself before even getting\nto the part where we do something with that element the second difficulty is with the type\nof the data structure it is kind of difficult to manage iteration on data for various types of\ndata structures you can see that iterating and accessing elements on a string is different from\niterating on an array so there was a need to iterate over various\ndata structures in a new way that abstracts away the complexity of accessing elements one by one and was at\nthe same time uniform across the different data structures\nthis would make our code more readable and less confusing that is exactly the reason for the\nintroduction of iterables and iterators in javascript iterables and iterators make it possible\nto access data from a collection one at a time which allow us to focus on what\nto do with the data rather than how to access the data in the year 2015 two new iteration\nprotocols were introduced which help with iteration they are the iterable and iterator\nprotocols it was also decided that some of the data structures would implement the\niterable protocol by default examples include strings arrays and two\nmore data structures which we haven't discussed namely maps and sets\nthey are termed as built-in iterables and a new looping construct which is the\nfor off loop was introduced to iterate over an iterable\nhere is how the loop works with the same string and array\nas you can see we don't really have to worry about accessing the element from the data structure\nit is just given to us one by one in a sequence allowing us to focus on the\nfunctionality of course i'm just logging the value to the console but you can add any functionality you want to\nbut clearly this is better than creating a variable i tracking its value and\nchecking conditions before accessing the next element but what exactly is an iterable\nlet's understand that now an object which implements the iterable\nprotocol is called an iterable well then what is the iterable protocol\nit states the following for an object to be an iterable it must\nimplement a method at the key symbol dot iterator\nthat method should not accept any argument and should return an object which conforms to the iterator protocol\nwhich now leads us to the question what is the iterator protocol\nthe iterator protocol decides whether an object is an iterator\nan object is an iterator when it satisfies the following rule\nthe object must have a next method that returns an object with two properties\nvalue which gives the current element and done which is a boolean value\nindicating whether or not there are any more elements that could be iterated upon\nnow if this made no sense whatsoever don't worry because i was on a similar\nboat when i started on this topic and for me what helped was implementing my own\nsimple iterable and iterator let's head back to vs code and do just\nthat consider an object which is not a built-in iterable so const obj is equal\nto an empty object our goal is to make this object an\niterable so that when this object is used with the for off loop it will print hello\nworld one word at a time for an object to be an iterable it must\nimplement a method at the key symbol dot iterator\nso add a key which is going to be symbol dot iterator\nand add this key we must implement a method\nthe final rule of the iterable protocol is that this method should not accept any argument and should return an object\nwhich conforms to the iterator protocol at the moment we don't know much about\nwhat an iterator is but we do know it's an object that implements the iterator protocol\nso i'm going to create an object called iterator and then return it\nconst iterator is an object i'm going to return\niterator this is pretty much the iterable protocol expressed in code\nnext we need to implement this iterator now an iterator is an object that has a\nmethod at the key next the method should return an object which\ncontains two properties value and done\nso in the iterator object we're going to define a method at the key next\nand this method will return an object which contains two properties\nvalue and done value gives the current element and done\nis a boolean value which indicates whether there are more elements to be iterated upon\ni'm currently not returning the object on line 145 because this is where we\nneed to come up with our logic so within the outer function defined at\nkey symbol.iterator we declare a variable called step\nand initialize it to zero within the inner function we increment the value of step by one\nand based on the value of this step variable we return the appropriate\nobject if step is 1\nwe return an object where value is going to be the string hello\nand done is set to false similarly\nelse if step is equal to two\nwe're going to return a similar object where value is world and done is still\nfalse so for step one and two we return hello\nand world and done is set to false when step goes beyond to\nwe return undefined and done is set to true so return\nan object where value is undefined and done is set to true\nso we are saying there is no more iteration necessary if we now use this object with a for off\nloop so for const word of obj\nconsole.log word run node main\nyou can see it locks the value hello followed by world our object\nis now an iterable to be more precise we have created our\nvery own iterable now similar to what we have done here\njavascript does it internally for strings arrays maps and sets\nthat is how you can easily iterate them with the for off loop\nhopefully you now know what are iterables and iterators in javascript"),(0,i.kt)("p",null,"Generators"),(0,i.kt)("p",null,"all right for the last topic in this advanced javascript crash course we're going to learn about generators\nwe've just seen how to create our very own iterable and iterator even though it is not difficult\nto make an iterator ourselves that is create an object with the next method\nand define its behavior it is definitely a verbose implementation\nwouldn't it be nice if there was something that would create an iterator for us instead of us having to write it\nthat is where generators come into picture generators are a special class of\nfunctions that simplify the task of writing iterators\nnow there is a lot to learn when it comes to generators but for this crash course we're only going to focus on the\npart where it relates to iterators in javascript in fact what we are going to do\nis rewrite this very hello world example using generators\nthat will allow you to compare and contrast writing our own iterators versus using generators\nall right so how can we create a generator in javascript we write functions using\nthe function keyword so function normal function parentheses and curly\nbraces a generator since it is a special function we use the function keyword\nfollowed by an asterisk function asterisk\ngenerator function parentheses curly braces\nbut what is so special about it now we all know that a normal function\nfollows the run to completion model so if i\nadd two log statements to log hello and world\nthis normal function what we have here will not stop before the last line is\nexecuted the function will log hello followed by world to the console\nthe only way to exit this function is by returning from it or throwing an\nerror so if we call normal function and run node main\nwe see hello and world if you call the function again\nit will begin execution from the top we say hello world and hello world\nin contrast a generator function is a function that can stop midway and then\ncontinue from where it stopped or you could say a generator function\ncan pause the execution to achieve that behavior\nwe use the yield keyword so yield hello\nand in the next line yield world\nyield is an operator with which a generator can pause itself\nevery time a generator encounters a yield it yields the value specified after it\nwe don't say it returns a value we say it yields a value\nnext let's talk about invocation we invoke a generator function by adding\nparentheses after the function name so generator function\nand parentheses however unlike returning a value from a normal\nfunction a generator function always returns what is called a generator object\nso const generator object is equal to the invocation of generator function\nand this generator object is an iterator so instead of us having to create an\niterator a generator function will create it for us and because the generator object is an\niterator it can be used in for-off loops so for\nconst word of generator object log to the console\nword if we clear the terminal and run node main you can see hello followed by world\nas you can see with generators we not only have created an iterable\nthat returns hello followed by world but we also have a simpler way to create\niterators we have achieved the same iteration behavior we had seen two minutes ago but this time it is much\nsimpler to define our custom iteration behavior i think it is a bit obvious looking at\nthe code the benefit we get from using the generator function\nfirst we don't have to worry about this symbol.iterator second we don't have to worry about\nimplementing the next method third we don't have to create the object\nthat is returned from the next method finally we don't have to be responsible\nfor managing the state in our iterator we have a variable called step that needs to be tracked\nbetween iterations however we have nothing of that sort in\na generator so that is about generators in javascript\ngenerators were introduced in 2015 and allow you to define an iterative\nbehavior by writing a single function whose execution is not continuous\nwell with that we come to the end of this crash course on advanced javascript"),(0,i.kt)("p",null,"Frontend Interview Course"),(0,i.kt)("p",null,"if you're interested in a deeper understanding and want to solve some challenging exercises on each of the\ntopics we have seen do make sure to check out my preparing for a frontend interview course where i\nelaborate on these topics it will surely give you an edge in your\nnext interview the link to the course is in the description down below"))}d.isMDXComponent=!0}}]);